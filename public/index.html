<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RustMarket Tracker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg: #0f1115;
        --card: #161a22;
        --text: #e6e8ee;
        --muted: #9aa3b2;
        --accent: #22c55e;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell,
          Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        background: var(--bg);
        color: var(--text);
      }
      header {
        padding: 16px 20px;
        display: flex;
        align-items: center;
        gap: 12px;
        border-bottom: 1px solid #1f2430;
      }
      header h1 {
        font-size: 20px;
        margin: 0;
        letter-spacing: 0.2px;
      }
      main {
        width: min(1400px, 100%);
        margin: 0 auto;
        padding: 20px;
      }
      .dashboard-layout {
        display: flex;
        gap: 16px;
        align-items: flex-start;
        margin-bottom: 16px;
      }
      .map-column {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .sidebar {
        width: 360px;
        max-width: 100%;
        display: flex;
        flex-direction: column;
        gap: 12px;
        position: sticky;
        top: 20px;
        align-self: stretch;
        height: calc(100vh - 120px);
        max-height: calc(100vh - 120px);
      }
      
      @media (max-width: 1180px) {
        .dashboard-layout {
          flex-direction: column;
        }
        .sidebar {
          position: static;
          height: auto;
          max-height: none;
        }
      }
      .map-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .map-header .controls {
        margin: 0;
        gap: 12px;
        align-items: center;
      }
      .controls {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 10px;
        margin-bottom: 16px;
      }
      button {
        background: var(--accent);
        color: #08210f;
        border: 0;
        padding: 8px 12px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
      }
      button[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .card {
        background: var(--card);
        border: 1px solid #1f2430;
        border-radius: 12px;
        padding: 16px;
      }
      .panel {
        border-radius: 12px;
        border: 1px solid #1f2430;
        background: var(--card);
        overflow: visible;
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
      }
      .panel-header {
        width: 100%;
        border: none;
        background: #10131a;
        color: var(--text);
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        font-size: 14px;
        cursor: pointer;
      }
      .panel-header .chevron {
        transition: transform 0.2s ease;
      }
      .panel[data-open="true"] .panel-header .chevron {
        transform: rotate(180deg);
      }
      .panel-body {
        padding: 16px;
        overflow: visible;
        position: relative;
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
      }
      .panel[data-open="false"] .panel-body {
        display: none;
      }
      .panel-status {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 10px;
      }
      .form-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .ghost {
        background: transparent;
        border: 1px solid #1f2430;
        color: var(--text);
      }
      .field {
        display: flex;
        flex-direction: column;
        gap: 4px;
        margin-bottom: 10px;
      }
      .field label {
        font-size: 11px;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        color: var(--muted);
      }
      .field input {
        height: 34px;
        border-radius: 8px;
        border: 1px solid #1c2232;
        background: #0f141d;
        color: var(--text);
        padding: 0 10px;
        font-size: 13px;
      }
      .tag-input {
        position: relative;
      }
      .tag-input input {
        width: 100%;
      }
      .suggestions {
        display: none;
        position: absolute;
        inset: auto 0 0;
        margin-top: 6px;
        background: #0f141d;
        border: 1px solid #1f2635;
        border-radius: 10px;
        max-height: 260px;
        overflow: auto;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
        z-index: 60;
      }
      .suggestions.open {
        display: block;
      }
      .suggestions button {
        width: 100%;
        text-align: left;
        border: none;
        background: none;
        color: #dfe7f3;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 4px;
        cursor: pointer;
      }
      .suggestions button:hover {
        background: #131826;
      }
      .suggestions small {
        color: #8aa5d0;
        font-size: 11px;
      }
      .chips {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-bottom: 8px;
      }
      .chip {
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid #1f2635;
        background: #131a27;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
      }
      .chip button {
        border: none;
        background: transparent;
        color: var(--muted);
        cursor: pointer;
      }
      .panel-list {
        margin-top: 10px;
        border-top: 1px solid #1a1f2e;
        padding-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        flex: 1;
        overflow: auto;
        min-height: 0;
      }
      .panel-list-header {
        font-size: 11px;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        color: #aab4c4;
      }
      .claim-row {
        border: 1px solid #1f2430;
        border-radius: 10px;
        padding: 10px;
        background: #0f141d;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .claim-row-header {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        align-items: flex-start;
      }
      .claim-row-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 12px;
        color: var(--muted);
      }
      .claim-row-actions {
        margin-top: 6px;
      }
      .panel-link {
        border: none;
        background: #233041;
        color: #a7c5ff;
        padding: 4px 10px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
      }
      .panel-summary {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .machine-row {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        padding: 8px;
        border-radius: 10px;
        border: 1px solid #1f202f;
        background: #0f141f;
        align-items: flex-start;
      }
      .machine-row-details {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .machine-row-meta {
        font-size: 12px;
        color: var(--muted);
      }
      .machine-row-actions {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .pill--highlight {
        background: #0c3724;
        color: #8ef1b6;
        border-color: #0a2f1d;
      }
      .pill--secondary {
        background: #0f111a;
        color: #8aa6d4;
        border-color: #111722;
      }
      .muted {
        color: var(--muted);
      }
      .error {
        color: #f87171;
        background: #2b1517;
        padding: 8px 10px;
        border: 1px solid #3a1b1d;
        border-radius: 8px;
      }
      footer {
        color: var(--muted);
        font-size: 12px;
        text-align: center;
        padding: 16px;
      }
      .cluster {
        position: absolute;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #1b8d4d;
        border: 2px solid #0b3;
        color: #eafff3;
        font-weight: 700;
        font-size: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 0 0 1px #0b3;
        cursor: pointer;
      }
      .vm-marker {
        position: absolute;
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: #22c55e;
        border: 1px solid #0b3;
        box-shadow: 0 0 0 1px #0b3;
        cursor: pointer;
      }
      .vm-marker.owned {
        background: #a855f7;
        border-color: #7c3aed;
        box-shadow: 0 0 0 1px #7c3aed;
      }
      .market-tracking {
        width: 100%;
        background: #0a0e14;
        border: 1px solid #1f2430;
        border-radius: 12px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .tracking-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-wrap: wrap;
        gap: 12px;
      }
      .tracking-title {
        font-weight: 700;
        font-size: 16px;
      }
      .tracking-filter {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .tracking-filter-row {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
      }
      .tracking-filter select,
      .tracking-filter input {
        height: 34px;
        border-radius: 8px;
        border: 1px solid #1c2232;
        background: #0f141d;
        color: var(--text);
        padding: 0 10px;
        font-size: 13px;
        min-width: 120px;
      }
      .tracking-filter .autocomplete-container {
        flex: 1;
        min-width: 200px;
      }
      .tracking-panels {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 12px;
      }
      .tracking-panel {
        border: 1px solid #1f2430;
        border-radius: 12px;
        background: #111625;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .tracking-panel-header {
        font-size: 12px;
        letter-spacing: 0.2px;
        text-transform: uppercase;
        color: #8aa5d0;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .tracking-panel-body {
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-height: 140px;
      }
      .tracking-row {
        display: flex;
        justify-content: space-between;
        gap: 12px;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid #1a1f2e;
        background: #0f141f;
        align-items: center;
      }
      .tracking-row-details {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .tracking-row small {
        color: #8aa5d0;
        font-size: 11px;
      }
      .tracking-row-actions {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .tracking-warning {
        display: none;
        background: #2d1305;
        border: 1px solid #f87171;
        color: #fdd7d5;
        border-radius: 10px;
        padding: 8px 12px;
        font-weight: 600;
      }
      .manual-entry {
        border-top: 1px solid #1f2430;
        padding-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .manual-entry .field {
        margin-bottom: 0;
      }
      .manual-entry .form-actions {
        padding-top: 6px;
      }
      .autocomplete-container {
        position: relative;
      }
      .autocomplete-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: #0f141d;
        border: 1px solid #1f2635;
        border-radius: 10px;
        max-height: 260px;
        overflow-y: auto;
        z-index: 100;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
        display: none;
      }
      .autocomplete-dropdown.active {
        display: block;
      }
      .autocomplete-item {
        padding: 10px;
        cursor: pointer;
        border-bottom: 1px solid #1a1f2e;
        display: flex;
        flex-direction: column;
        gap: 4px;
        transition: background-color 0.15s ease;
      }
      .autocomplete-item:last-child {
        border-bottom: none;
      }
      .autocomplete-item:hover,
      .autocomplete-item.selected {
        background: #131826;
      }
      .autocomplete-item-name {
        font-weight: 600;
        color: var(--text);
      }
      .autocomplete-item-details {
        font-size: 11px;
        color: var(--muted);
      }
      .autocomplete-item-highlight {
        color: #22c55e;
        font-weight: 600;
      }
      .form-error {
        background: #2b1517;
        border: 1px solid #3a1b1d;
        color: #f87171;
        padding: 6px 8px;
        border-radius: 6px;
        font-size: 12px;
        margin-top: 4px;
        display: none;
      }
      .form-error.active {
        display: block;
      }
      .quick-add-section {
        border-top: 1px solid #1f2430;
        padding-top: 10px;
        margin-top: 10px;
      }
      .quick-add-title {
        font-size: 11px;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        color: var(--muted);
        margin-bottom: 8px;
      }
      .quick-add-chips {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .quick-add-chip {
        background: #1a2332;
        border: 1px solid #2a3444;
        color: #a7c5ff;
        padding: 4px 8px;
        border-radius: 12px;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.15s ease;
      }
      .quick-add-chip:hover {
        background: #223041;
        border-color: #3a4858;
        transform: translateY(-1px);
      }
      .validation-hint {
        font-size: 10px;
        color: var(--muted);
        margin-top: 2px;
        height: 12px;
      }
      .validation-hint.error {
        color: #f87171;
      }
      .validation-hint.success {
        color: #22c55e;
      }
      #mapWrap {
        cursor: grab;
      }
      #mapWrap.dragging {
        cursor: grabbing;
      }
      #popup {
        position: absolute;
        display: none;
        min-width: 280px;
        max-width: 440px;
        background: #0f141d;
        border: 1px solid #222a3a;
        border-radius: 10px;
        padding: 10px 12px;
        color: #e6e8ee;
        box-shadow: 0 16px 30px rgba(0, 0, 0, 0.5);
        z-index: 5;
        backdrop-filter: blur(3px);
      }
      #popup .hdr {
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 6px;
      }
      #popup .title {
        font-weight: 700;
      }
      #popup .hint {
        color: var(--muted);
        margin-bottom: 6px;
      }
      #popup .btn {
        background: #233041;
        color: #a7c5ff;
        border: 1px solid #2a3850;
        padding: 4px 8px;
        border-radius: 6px;
        cursor: pointer;
      }
      .popup-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        font-size: 13px;
      }
      .popup-table th,
      .popup-table td {
        text-align: left;
        padding: 4px 6px;
        border-bottom: 1px solid #1f2535;
      }
      .popup-table th {
        font-size: 11px;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        color: #aab4c4;
      }
      .popup-sale {
        color: #4ade80;
        font-weight: 600;
      }
      .popup-cost {
        color: #f87171;
        font-weight: 600;
      }
      .popup-stock {
        color: #c0c9d9;
        text-align: right;
      }
      .undercut-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
        background: #1a1f2e;
        border-radius: 8px;
        overflow: hidden;
      }
      .undercut-table th,
      .undercut-table td {
        padding: 8px 10px;
        text-align: left;
        border-bottom: 1px solid #2a3444;
      }
      .undercut-table th {
        background: #232937;
        font-size: 11px;
        letter-spacing: 0.3px;
        text-transform: uppercase;
        color: #aab4c4;
        font-weight: 600;
      }
      .undercut-table tr:last-child td {
        border-bottom: none;
      }
      .undercut-table .your-offer {
        color: #22c55e;
        font-weight: 600;
      }
      .undercut-table .best-offer {
        color: #f87171;
        font-weight: 600;
      }
      .undercut-banner {
        background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        border: 2px solid #f87171;
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 12px;
        animation: pulse-warning 2s infinite;
      }
      .banner-content {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .banner-icon {
        font-size: 24px;
        animation: bounce-warning 1s infinite;
      }
      .banner-text {
        color: white;
      }
      .banner-subtitle {
        font-size: 12px;
        opacity: 0.9;
        margin-top: 2px;
      }
      @keyframes pulse-warning {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.8; }
      }
      @keyframes bounce-warning {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
      }
      .undercut-table .focus-btn {
        background: #233041;
        color: #a7c5ff;
        border: 1px solid #2a3850;
        padding: 3px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        text-decoration: none;
        display: inline-block;
      }
      .undercut-table .focus-btn:hover {
        background: #2a3850;
      }
      .item-group {
        border: 1px solid #1f2430;
        border-radius: 10px;
        background: #0f141f;
        margin-bottom: 8px;
        overflow: hidden;
      }
      .item-group-header {
        padding: 10px 12px;
        background: #161a22;
        border-bottom: 1px solid #1f2430;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .item-group-header:hover {
        background: #1a1f2e;
      }
      .item-group-header .item-name {
        font-weight: 600;
        color: var(--text);
      }
      .item-group-header .offer-count {
        font-size: 12px;
        color: var(--muted);
        background: #1a1f2e;
        padding: 2px 8px;
        border-radius: 12px;
      }
      .item-group-chevron {
        color: var(--muted);
        transition: transform 0.2s ease;
        font-size: 12px;
      }
      .item-group.expanded .item-group-chevron {
        transform: rotate(180deg);
      }
      .item-group-offers {
        display: none;
        padding: 8px;
      }
      .item-group.expanded .item-group-offers {
        display: block;
      }
      .offer-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 10px;
        border-radius: 6px;
        margin-bottom: 4px;
        background: #0a0e14;
        border: 1px solid #1a1f2e;
      }
      .offer-row:last-child {
        margin-bottom: 0;
      }
      .offer-row-details {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .offer-row-details small {
        color: var(--muted);
        font-size: 11px;
      }
      .offer-row-actions {
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .focus-offer-btn {
        background: #233041;
        color: #a7c5ff;
        border: 1px solid #2a3850;
        padding: 3px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 11px;
        text-decoration: none;
        display: inline-block;
      }
      .focus-offer-btn:hover {
        background: #2a3850;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>RustMarket Tracker</h1>
      <span id="serverName" class="muted"></span>
    </header>
    <main>
      <div class="dashboard-layout">
        <section class="map-column card">
          <div class="map-header">
            <strong>Map</strong>
            <div class="controls map-controls">
              <div id="searchBox" style="position: relative">
                <input
                  id="search"
                  type="text"
                  placeholder="Search items…"
                  style="height:34px;width:360px;border-radius:8px;border:1px solid #263043;background:#0f141c;color:#e6e8ee;padding:0 10px;outline:none;"
                />
                <div
                  id="searchResults"
                  style="display:none;position:absolute;right:0;top:38px;width:420px;max-height:380px;overflow:auto;background:#0f141d;border:1px solid #263043;border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,0.4);z-index:6;"
                ></div>
              </div>
              <button id="mapReset">Reset</button>
            </div>
          </div>
          <div
            id="mapWrap"
            style="position:relative;overflow:hidden;height:520px;border-radius:8px;border:1px solid #1f2430;background:#0c0f14;"
          >
            <img
              id="mapImg"
              alt="Map"
              draggable="false"
              style="position:absolute;left:0;top:0;transform-origin:0 0;user-select:none;-webkit-user-drag:none;"
            />
            <div
              id="markerLayer"
              style="position:absolute;left:0;top:0;transform-origin:0 0;"
            ></div>
            <div id="popup"></div>
          </div>
          <section class="market-tracking card">
            <div class="tracking-header">
              <div>
                <div class="tracking-title">Market Tracking</div>
                <div class="tracking-filter">
                  <label for="trackingCurrency" class="muted" style="font-size:11px;letter-spacing:0.3px;text-transform:uppercase;">Currency</label>
                  <div class="tracking-filter-row">
                    <select id="trackingCurrency" style="min-width: 120px;">
                      <option value="all">All</option>
                      <option value="scrap">Scrap</option>
                      <option value="hqm">High Quality Metal</option>
                      <option value="other">Other…</option>
                    </select>
                    <div id="trackingCurrencyOtherContainer" class="autocomplete-container" style="display:none;flex: 1;min-width: 200px; position: relative;">
                      <input
                        id="trackingCurrencyOther"
                        placeholder="Start typing currency name…"
                        autocomplete="off"
                        style="width: 100%;"
                      />
                      <div id="trackingCurrencyOtherDropdown" class="autocomplete-dropdown"></div>
                      <div id="trackingCurrencyOtherError" class="form-error"></div>
                      <div id="trackingCurrencyOtherCheckmark" class="checkmark-indicator" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); opacity: 0; transition: opacity 0.3s ease; font-size: 16px;">✓</div>
                    </div>
                  </div>
                </div>
              </div>
              <button type="button" id="trackingRefresh">Refresh tracking</button>
            </div>
            <div id="undercutBanner" class="undercut-banner" style="display:none;">
              <div class="banner-content">
                <div class="banner-icon">⚠️</div>
                <div class="banner-text">
                  <strong>Your offers are being undercut!</strong>
                  <div class="banner-subtitle">Competing offers found at lower prices</div>
                </div>
              </div>
            </div>
            <div id="trackingWarning" class="tracking-warning" style="display:none;"></div>
            <div id="trackingWarningTable" style="display:none; margin-top: 12px;"></div>
            <div class="tracking-panels">
              <div class="tracking-panel">
                <div class="tracking-panel-header">
                  <span>My Offers</span>
                  <div style="display: flex; align-items: center; gap: 8px;">
                    <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; cursor: pointer; color: var(--muted);">
                      <input type="checkbox" id="myOffersStockToggle" style="margin: 0;">
                      <span>Include out of stock</span>
                    </label>
                    <span class="muted" id="myOffersSummary">No offers yet</span>
                  </div>
                </div>
                <div class="tracking-panel-body" id="myOffersBody">
                  <div class="muted">Your owned vending machines will populate this view.</div>
                </div>
                <div class="manual-entry" id="manualEntry" style="display:none;">
                  <p class="muted" style="font-size:12px;margin:0;">
                    No owned vending machines detected. Add manual offers via search.
                  </p>
                  
                  <div class="field">
                    <label for="manualItem">Item</label>
                    <div class="autocomplete-container">
                      <input
                        id="manualItem"
                        placeholder="Start typing to search items…"
                        autocomplete="off"
                        style="width: 100%;"
                      />
                      <div id="manualItemDropdown" class="autocomplete-dropdown"></div>
                      <div id="manualItemError" class="form-error"></div>
                      <div id="manualItemHint" class="validation-hint"></div>
                    </div>
                  </div>
                  
                  <div class="field">
                    <label for="manualCurrency">Currency</label>
                    <div class="autocomplete-container">
                      <input
                        id="manualCurrency"
                        placeholder="Currency name or ID"
                        autocomplete="off"
                        style="width: 100%;"
                      />
                      <div id="manualCurrencyDropdown" class="autocomplete-dropdown"></div>
                      <div id="manualCurrencyError" class="form-error"></div>
                      <div id="manualCurrencyHint" class="validation-hint"></div>
                    </div>
                  </div>
                  
                  <div class="field">
                    <label for="manualCost">Cost per item</label>
                    <input
                      id="manualCost"
                      type="number"
                      min="0"
                      step="0.01"
                      placeholder="Enter cost amount"
                      style="width: 100%;"
                    />
                    <div id="manualCostError" class="form-error"></div>
                    <div id="manualCostHint" class="validation-hint"></div>
                  </div>
                  
                  <div class="field">
                    <label for="manualStock">Stock</label>
                    <input
                      id="manualStock"
                      type="number"
                      min="0"
                      step="1"
                      placeholder="Amount in stock (optional)"
                      style="width: 100%;"
                    />
                    <div id="manualStockError" class="form-error"></div>
                    <div id="manualStockHint" class="validation-hint"></div>
                  </div>
                  
                  <div class="form-actions">
                    <button type="button" id="manualAdd" class="primary">Add manual offer</button>
                    <button type="button" id="manualClear" class="ghost">Clear form</button>
                  </div>
                  
                  <div class="quick-add-section">
                    <div class="quick-add-title">Quick add common items:</div>
                    <div class="quick-add-chips" id="quickAddChips">
                      <button class="quick-add-chip" data-item="Scrap" data-currency="Scrap">Scrap</button>
                      <button class="quick-add-chip" data-item="High Quality Metal" data-currency="High Quality Metal">HQM</button>
                      <button class="quick-add-chip" data-item="Metal Fragments" data-currency="Scrap">Metal Fragments</button>
                      <button class="quick-add-chip" data-item="Stones" data-currency="Scrap">Stones</button>
                      <button class="quick-add-chip" data-item="Wood" data-currency="Scrap">Wood</button>
                      <button class="quick-add-chip" data-item="Cloth" data-currency="Scrap">Cloth</button>
                    </div>
                  </div>
                </div>
              </div>
              <div class="tracking-panel">
                <div class="tracking-panel-header">
                  <span>Others</span>
                  <div style="display: flex; flex-direction: column; gap: 4px;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                      <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; cursor: pointer; color: var(--muted);">
                        <input type="checkbox" id="othersFilterToggle" style="margin: 0;">
                        <span>Match my offers</span>
                      </label>
                      <span class="muted" id="othersSummary">No offers yet</span>
                    </div>
                    <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; cursor: pointer; color: var(--muted);">
                      <input type="checkbox" id="othersStockToggle" style="margin: 0;">
                      <span>Include out of stock</span>
                    </label>
                  </div>
                </div>
                <div class="tracking-panel-body" id="othersBody">
                  <div class="muted">Other players’ sell orders appear here.</div>
                </div>
              </div>
            </div>
          </section>
        </section>
        <aside class="sidebar">
          <section class="panel card" data-open="true">
            <button class="panel-header" type="button">
              <span>Owned Machines</span>
              <span class="chevron">▾</span>
            </button>
            <div class="panel-body">
              <div id="claimsStatus" class="panel-status">Loading owned machines…</div>
              <div id="claimsList" class="panel-list"></div>
              <form id="claimForm">
                <div class="field">
                  <label for="claimMachineName">Machine Name (Lookup)</label>
                  <div class="autocomplete-container">
                    <input
                      id="claimMachineName"
                      name="machineName"
                      placeholder="Start typing machine name…"
                      autocomplete="off"
                      style="width: 100%;"
                    />
                    <div id="claimMachineNameDropdown" class="autocomplete-dropdown"></div>
                    <div id="claimMachineNameError" class="form-error"></div>
                    <div id="claimMachineNameHint" class="validation-hint"></div>
                  </div>
                </div>
                <div class="field">
                  <label for="claimMachineId">Machine ID</label>
                  <input
                    id="claimMachineId"
                    name="machineId"
                    placeholder="Enter machine identifier"
                    required
                  />
                  <div id="claimMachineIdHint" class="validation-hint" style="font-size: 10px; color: var(--muted); margin-top: 2px; height: 12px;"></div>
                </div>
                <div class="form-actions">
                  <button type="submit">Take ownership</button>
                  <button type="button" id="claimsRefresh" class="ghost">Refresh list</button>
                </div>
                <div id="claimFeedback" class="muted" aria-live="polite" style="min-height:18px"></div>
              </form>
            </div>
          </section>
        </aside>
      </div>
      <div class="controls">
        <button id="refresh">Refresh</button>
        <span id="status" class="muted">Loading…</span>
      </div>
      <div id="error" class="error" style="display:none"></div>
    </main>
    <footer>Data shown from Rust+ websocket.</footer>
    <script type="module">
      const elStatus = document.getElementById('status');
      const elError = document.getElementById('error');
      const elRefresh = document.getElementById('refresh');
      const elServerName = document.getElementById('serverName');
      const elMapImg = document.getElementById('mapImg');
      const elMarkerLayer = document.getElementById('markerLayer');
      const elMapWrap = document.getElementById('mapWrap');
      const elMapReset = document.getElementById('mapReset');
      const elPopup = document.getElementById('popup');
      const elSearch = document.getElementById('search');
      const elSearchResults = document.getElementById('searchResults');

      const elClaimsList = document.getElementById('claimsList');
      const elClaimsStatus = document.getElementById('claimsStatus');
      const elClaimsRefresh = document.getElementById('claimsRefresh');
      const elClaimForm = document.getElementById('claimForm');
      const elClaimMachineName = document.getElementById('claimMachineName');
      const elClaimMachineId = document.getElementById('claimMachineId');
      const elClaimFeedback = document.getElementById('claimFeedback');
 
      const elTrackingCurrency = document.getElementById('trackingCurrency');
      const elTrackingCurrencyOther = document.getElementById('trackingCurrencyOther');
      const elTrackingCurrencyOtherContainer = document.getElementById('trackingCurrencyOtherContainer');
      const elMyOffersBody = document.getElementById('myOffersBody');
      const elMyOffersSummary = document.getElementById('myOffersSummary');
      const elOthersBody = document.getElementById('othersBody');
      const elOthersSummary = document.getElementById('othersSummary');
      const elTrackingWarning = document.getElementById('trackingWarning');
      const elManualEntry = document.getElementById('manualEntry');
      const elManualItem = document.getElementById('manualItem');
      const elManualCurrency = document.getElementById('manualCurrency');
      const elManualCost = document.getElementById('manualCost');
      const elManualStock = document.getElementById('manualStock');
      const elManualItemList = document.getElementById('manualItemList');
      const elTrackingRefresh = document.getElementById('trackingRefresh');
      const elOthersFilterToggle = document.getElementById('othersFilterToggle');
      const elMyOffersStockToggle = document.getElementById('myOffersStockToggle');
      const elOthersStockToggle = document.getElementById('othersStockToggle');
      const elTrackingWarningTable = document.getElementById('trackingWarningTable');
      const elUndercutBanner = document.getElementById('undercutBanner');
      
      // New enhanced manual entry elements
      const elManualItemDropdown = document.getElementById('manualItemDropdown');
      const elManualCurrencyDropdown = document.getElementById('manualCurrencyDropdown');
      const elManualItemError = document.getElementById('manualItemError');
      const elManualCurrencyError = document.getElementById('manualCurrencyError');
      const elManualCostError = document.getElementById('manualCostError');
      const elManualStockError = document.getElementById('manualStockError');
      const elManualItemHint = document.getElementById('manualItemHint');
      const elManualCurrencyHint = document.getElementById('manualCurrencyHint');
      const elManualCostHint = document.getElementById('manualCostHint');
      const elManualStockHint = document.getElementById('manualStockHint');
      const elManualClear = document.getElementById('manualClear');
      const elQuickAddChips = document.getElementById('quickAddChips');
      
      // New machine name lookup elements
      const elClaimMachineNameDropdown = document.getElementById('claimMachineNameDropdown');
      const elClaimMachineNameError = document.getElementById('claimMachineNameError');
      const elClaimMachineNameHint = document.getElementById('claimMachineNameHint');
      const elClaimMachineIdHint = document.getElementById('claimMachineIdHint');
      
      // New smart currency lookup elements
      const elTrackingCurrencyOtherDropdown = document.getElementById('trackingCurrencyOtherDropdown');
      const elTrackingCurrencyOtherError = document.getElementById('trackingCurrencyOtherError');
      const elTrackingCurrencyOtherCheckmark = document.getElementById('trackingCurrencyOtherCheckmark');
      
      const elManualAdd = document.getElementById('manualAdd');
 
      const manualOffers = [];
      let currencyFilter = { type: 'all', custom: '' };
      let showOnlyMatchingItems = false;
      let includeOutOfStockMyOffers = false;
      let includeOutOfStockOthers = false;
      const chimeAudio = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');
      chimeAudio.volume = 0.2;
 
      // Enhanced Manual Entry System with Smart Autocomplete
      class SmartAutocomplete {
        constructor(inputElement, dropdownElement, errorElement, hintElement, options = {}) {
          this.input = inputElement;
          this.dropdown = dropdownElement;
          this.error = errorElement;
          this.hint = hintElement;
          this.options = {
            minQueryLength: options.minQueryLength || 1,
            maxResults: options.maxResults || 50,
            debounceMs: options.debounceMs || 150,
            ...options
          };
          
          this.currentResults = [];
          this.selectedIndex = -1;
          this.debounceTimer = null;
          this.selectedItem = null;
          
          this.setupEventListeners();
        }
        
        setupEventListeners() {
          // Input events
          this.input.addEventListener('input', (e) => this.handleInput(e));
          this.input.addEventListener('focus', () => this.handleFocus());
          this.input.addEventListener('blur', () => this.handleBlur());
          this.input.addEventListener('keydown', (e) => this.handleKeyDown(e));
          
          // Dropdown events
          this.dropdown.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        }
        
        handleInput(e) {
          const query = e.target.value.trim();
          this.clearError();
          this.clearHint();
          
          if (query.length < this.options.minQueryLength) {
            this.hide();
            this.selectedItem = null;
            return;
          }
          
          clearTimeout(this.debounceTimer);
          this.debounceTimer = setTimeout(() => {
            this.search(query);
          }, this.options.debounceMs);
        }
        
        handleFocus() {
          const query = this.input.value.trim();
          if (query.length >= this.options.minQueryLength) {
            this.search(query);
          }
        }
        
        handleBlur() {
          // Delay hiding to allow click events on dropdown
          setTimeout(() => this.hide(), 150);
        }
        
        handleKeyDown(e) {
          if (!this.isVisible()) return;
          
          switch (e.key) {
            case 'ArrowDown':
              e.preventDefault();
              this.selectNext();
              break;
            case 'ArrowUp':
              e.preventDefault();
              this.selectPrevious();
              break;
            case 'Enter':
              e.preventDefault();
              this.selectCurrent();
              break;
            case 'Escape':
              e.preventDefault();
              this.hide();
              break;
          }
        }
        
        handleMouseDown(e) {
          const item = e.target.closest('.autocomplete-item');
          if (item) {
            e.preventDefault();
            this.selectItem(item.dataset.index);
          }
        }
        
        async search(query) {
          if (!this.options.searchFn) {
            return;
          }
          
          try {
            const results = await this.options.searchFn(query);
            this.currentResults = results.slice(0, this.options.maxResults);
            this.selectedIndex = -1;
            this.render();
          } catch (error) {
            this.showError('Search failed. Please try again.');
          }
        }
        
        render() {
          if (this.currentResults.length === 0) {
            this.showNoResults();
            return;
          }
          
          const html = this.currentResults.map((item, index) => this.renderItem(item, index)).join('');
          this.dropdown.innerHTML = html;
          this.show();
        }
        
        renderItem(item, index) {
          const highlight = (text) => {
            const query = this.input.value.trim();
            if (!query) return escapeHtml(text);
            const regex = new RegExp(`(${escapeRegExp(query)})`, 'gi');
            return escapeHtml(text).replace(regex, '<span class="autocomplete-item-highlight">$1</span>');
          };
          
          return `
            <div class="autocomplete-item" data-index="${index}">
              <div class="autocomplete-item-name">${highlight(item.name)}</div>
              ${item.details ? `<div class="autocomplete-item-details">${item.details}</div>` : ''}
            </div>
          `;
        }
        
        showNoResults() {
          this.dropdown.innerHTML = `
            <div class="autocomplete-item" style="color: var(--muted); cursor: default;">
              No results found
            </div>
          `;
          this.show();
        }
        
        selectNext() {
          if (this.currentResults.length === 0) return;
          this.selectedIndex = (this.selectedIndex + 1) % this.currentResults.length;
          this.updateSelection();
        }
        
        selectPrevious() {
          if (this.currentResults.length === 0) return;
          this.selectedIndex = this.selectedIndex <= 0 ? this.currentResults.length - 1 : this.selectedIndex - 1;
          this.updateSelection();
        }
        
        selectCurrent() {
          if (this.selectedIndex >= 0 && this.selectedIndex < this.currentResults.length) {
            this.selectItem(this.selectedIndex);
          }
        }
        
        selectItem(index) {
          const item = this.currentResults[index];
          if (!item) return;
          
          this.selectedItem = item;
          this.input.value = item.name;
          this.hide();
          this.showSuccess('Item selected');
          
          if (this.options.onSelect) {
            this.options.onSelect(item);
          }
        }
        
        updateSelection() {
          const items = this.dropdown.querySelectorAll('.autocomplete-item');
          items.forEach((item, index) => {
            if (index === this.selectedIndex) {
              item.classList.add('selected');
              item.scrollIntoView({ block: 'nearest' });
            } else {
              item.classList.remove('selected');
            }
          });
        }
        
        show() {
          this.dropdown.classList.add('active');
        }
        
        hide() {
          this.dropdown.classList.remove('active');
          this.selectedIndex = -1;
        }
        
        isVisible() {
          return this.dropdown.classList.contains('active');
        }
        
        showError(message) {
          if (this.error) {
            this.error.textContent = message;
            this.error.classList.add('active');
          }
        }
        
        showSuccess(message) {
          if (this.hint) {
            this.hint.textContent = message;
            this.hint.classList.add('success');
            setTimeout(() => this.clearHint(), 2000);
          }
        }
        
        clearError() {
          if (this.error) {
            this.error.classList.remove('active');
            this.error.textContent = '';
          }
        }
        
        clearHint() {
          if (this.hint) {
            this.hint.classList.remove('success', 'error');
            this.hint.textContent = '';
          }
        }
        
        reset() {
          this.hide();
          this.clearError();
          this.clearHint();
          this.selectedItem = null;
          this.currentResults = [];
          this.selectedIndex = -1;
        }
        
        getSelectedItem() {
          return this.selectedItem;
        }
      }
      
      // Utility function for regex escaping
      function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }
      
      // Fuzzy search implementation with ranking
      function fuzzySearch(query, items, searchFields) {
        const normalizedQuery = query.toLowerCase().trim();
        if (!normalizedQuery) return [];
        
        return items
          .map(item => {
            let score = 0;
            let fieldMatches = 0;
            
            for (const field of searchFields) {
              const fieldValue = String(item[field] || '').toLowerCase();
              if (fieldValue.includes(normalizedQuery)) {
                // Exact match gets highest score
                if (fieldValue === normalizedQuery) {
                  score += 100;
                } else if (fieldValue.startsWith(normalizedQuery)) {
                  score += 80;
                } else {
                  score += 60;
                }
                fieldMatches++;
                
                // Bonus for shorter field names (more specific)
                score += Math.max(0, 20 - fieldValue.length);
              } else if (fuzzyMatch(normalizedQuery, fieldValue)) {
                // Fuzzy match gets lower score
                score += 30;
                fieldMatches++;
              }
            }
            
            return { item, score, fieldMatches };
          })
          .filter(result => result.fieldMatches > 0)
          .sort((a, b) => b.score - a.score)
          .map(result => result.item);
      }
      
      // Simple fuzzy matching
      function fuzzyMatch(query, text) {
        let queryIndex = 0;
        let textIndex = 0;
        
        while (queryIndex < query.length && textIndex < text.length) {
          if (query[queryIndex] === text[textIndex]) {
            queryIndex++;
          }
          textIndex++;
        }
        
        return queryIndex === query.length;
      }
      
      // Initialize smart autocomplete for items
      let itemAutocomplete = null;
      let currencyAutocomplete = null;
      let machineNameAutocomplete = null;
      let trackingCurrencyAutocomplete = null;
      
      function initializeAutocompletes() {
        // Item autocomplete
        itemAutocomplete = new SmartAutocomplete(
          elManualItem,
          elManualItemDropdown,
          elManualItemError,
          elManualItemHint,
          {
            minQueryLength: 1,
            maxResults: 30,
            searchFn: async (query) => {
              const items = searchIndex.map(entry => ({
                name: entry.item || entry.itemName || `Item ${entry.itemId || ''}`,
                itemId: entry.itemId,
                details: `ID: ${entry.itemId || 'Unknown'} · Found in ${entry.quantity} orders`
              }));
              
              // Remove duplicates
              const uniqueItems = new Map();
              items.forEach(item => {
                if (!uniqueItems.has(item.name)) {
                  uniqueItems.set(item.name, item);
                }
              });
              
              return fuzzySearch(query, Array.from(uniqueItems.values()), ['name', 'details']);
            },
            onSelect: (item) => {
              validateItemSelection(item);
            }
          }
        );
        
        // Currency autocomplete
        currencyAutocomplete = new SmartAutocomplete(
          elManualCurrency,
          elManualCurrencyDropdown,
          elManualCurrencyError,
          elManualCurrencyHint,
          {
            minQueryLength: 1,
            maxResults: 20,
            searchFn: async (query) => {
              // Extract unique currencies from search index
              const currencies = new Map();
              searchIndex.forEach(entry => {
                const currencyName = entry.currency || 'Unknown';
                if (!currencies.has(currencyName)) {
                  currencies.set(currencyName, {
                    name: currencyName,
                    details: `Used in market transactions`
                  });
                }
              });
              
              // Add common currencies
              const commonCurrencies = [
                { name: 'Scrap', details: 'Common crafting material' },
                { name: 'High Quality Metal', details: 'High-tier crafting material' },
                { name: 'Metal Fragments', details: 'Basic crafting material' },
                { name: 'Stones', details: 'Basic building material' },
                { name: 'Wood', details: 'Basic building material' }
              ];
              
              commonCurrencies.forEach(curr => {
                if (!currencies.has(curr.name)) {
                  currencies.set(curr.name, curr);
                }
              });
              
              return fuzzySearch(query, Array.from(currencies.values()), ['name', 'details']);
            },
            onSelect: (item) => {
              validateCurrencySelection(item);
            }
          }
        );
        
        // Machine Name autocomplete for Owned Machines section
        machineNameAutocomplete = new SmartAutocomplete(
          elClaimMachineName,
          elClaimMachineNameDropdown,
          elClaimMachineNameError,
          elClaimMachineNameHint,
          {
            minQueryLength: 1,
            maxResults: 30,
            searchFn: async (query) => {
              if (!latestVending || !latestVending.machines) {
                return [];
              }
              
              const machines = latestVending.machines.map(machine => ({
                name: machine.name || `Vending Machine #${machine.id}`,
                machineId: String(machine.id),
                details: `ID: ${machine.id} · (${machine.x?.toFixed(0) || '?'}, ${machine.y?.toFixed(0) || '?'})`
              }));
              
              return fuzzySearch(query, machines, ['name', 'details']);
            },
            onSelect: (item) => {
              // Auto-populate the Machine ID field
              elClaimMachineId.value = item.machineId;
              elClaimMachineIdHint.textContent = `✓ Selected: ${item.name} (ID: ${item.machineId})`;
              elClaimMachineIdHint.className = 'validation-hint success';
              
              // Clear any previous errors
              hideFieldError(elClaimMachineNameError);
            }
          }
        );
        
        // Smart Currency autocomplete for Market Tracking
        trackingCurrencyAutocomplete = new SmartAutocomplete(
          elTrackingCurrencyOther,
          elTrackingCurrencyOtherDropdown,
          elTrackingCurrencyOtherError,
          null, // Using checkmark instead of hint element
          {
            minQueryLength: 1,
            maxResults: 25,
            searchFn: async (query) => {
              // Enhanced currency data source
              const currencies = new Map();
              
              // Extract currencies from search index
              if (searchIndex.length > 0) {
                searchIndex.forEach(entry => {
                  const currencyName = entry.currency || 'Unknown';
                  if (!currencies.has(currencyName) && currencyName !== 'Unknown') {
                    currencies.set(currencyName, {
                      name: currencyName,
                      details: `Used in market transactions`
                    });
                  }
                });
              }
              
              // Add commonly used currencies with enhanced details
              const commonCurrencies = [
                { name: 'Scrap', details: 'Common crafting material & trading currency' },
                { name: 'High Quality Metal', details: 'High-tier crafting material' },
                { name: 'Metal Fragments', details: 'Basic crafting material' },
                { name: 'Stones', details: 'Basic building material' },
                { name: 'Wood', details: 'Basic building material' },
                { name: 'Cloth', details: 'Crafting material' },
                { name: 'Gunpowder', details: 'Ammunition crafting' },
                { name: 'Low Grade Fuel', details: 'Fuel & crafting' },
                { name: 'Animal Fat', details: 'Cooking & crafting' },
                { name: 'Leather', details: 'Crafting material' },
                { name: 'Rope', details: 'Crafting material' },
                { name: 'Duct Tape', details: 'Repair material' },
                { name: 'Gears', details: 'High-tier components' },
                { name: 'Sheet Metal', details: 'Building material' },
                { name: 'Tech Trash', details: 'High-tier crafting' },
                { name: 'Road Signs', details: ' Scrap alternative' }
              ];
              
              commonCurrencies.forEach(curr => {
                if (!currencies.has(curr.name)) {
                  currencies.set(curr.name, curr);
                }
              });
              
              return fuzzySearch(query, Array.from(currencies.values()), ['name', 'details']);
            },
            onSelect: (item) => {
              // Update currency filter and show checkmark
              currencyFilter.custom = item.name;
              
              // Show checkmark with fade effect
              const checkmark = document.getElementById('trackingCurrencyOtherCheckmark');
              if (checkmark) {
                checkmark.style.opacity = '1';
                setTimeout(() => {
                  checkmark.style.opacity = '0';
                }, 1500);
              }
              
              // Trigger market tracking re-render
              if (latestVending) {
                renderMarketTracking(latestVending);
              }
              
              hideFieldError(elTrackingCurrencyOtherError);
            }
          }
        );
      }
      
      function validateItemSelection(item) {
        // Cross-validate with search index
        const found = searchIndex.some(entry =>
          (entry.item || entry.itemName) === item.name
        );
        
        if (found) {
          elManualItemHint.textContent = '✓ Valid item';
          elManualItemHint.className = 'validation-hint success';
          return true;
        } else {
          elManualItemHint.textContent = '⚠ Item not found in market';
          elManualItemHint.className = 'validation-hint error';
          return false;
        }
      }
      
      function validateCurrencySelection(item) {
        // Check if it's a known currency
        const knownCurrencies = ['Scrap', 'High Quality Metal', 'Metal Fragments', 'Stones', 'Wood', 'Cloth'];
        const isKnown = knownCurrencies.some(curr =>
          curr.toLowerCase() === item.name.toLowerCase()
        );
        
        if (isKnown || searchIndex.some(entry => entry.currency === item.name)) {
          elManualCurrencyHint.textContent = '✓ Valid currency';
          elManualCurrencyHint.className = 'validation-hint success';
          return true;
        } else {
          elManualCurrencyHint.textContent = '⚠ Unknown currency';
          elManualCurrencyHint.className = 'validation-hint error';
          return false;
        }
      }

      function loadFilterState() {
        const stored = localStorage.getItem('marketTrackingFilter');
        if (stored !== null) {
          showOnlyMatchingItems = JSON.parse(stored);
          elOthersFilterToggle.checked = showOnlyMatchingItems;
        }
        
        const storedMyStock = localStorage.getItem('marketTrackingMyStock');
        if (storedMyStock !== null) {
          includeOutOfStockMyOffers = JSON.parse(storedMyStock);
          elMyOffersStockToggle.checked = includeOutOfStockMyOffers;
        }
        
        const storedOthersStock = localStorage.getItem('marketTrackingOthersStock');
        if (storedOthersStock !== null) {
          includeOutOfStockOthers = JSON.parse(storedOthersStock);
          elOthersStockToggle.checked = includeOutOfStockOthers;
        }
      }

      function saveFilterState() {
        localStorage.setItem('marketTrackingFilter', JSON.stringify(showOnlyMatchingItems));
        localStorage.setItem('marketTrackingMyStock', JSON.stringify(includeOutOfStockMyOffers));
        localStorage.setItem('marketTrackingOthersStock', JSON.stringify(includeOutOfStockOthers));
      }

      function escapeHtml(value) {
        if (value == null) return '';
        return String(value)
          .replace(/&/g, '&')
          .replace(/</g, '<')
          .replace(/>/g, '>');
      }

      function showError(msg) {
        elError.textContent = msg;
        elError.style.display = 'block';
      }

      function clearError() {
        elError.textContent = '';
        elError.style.display = 'none';
      }

      function itemRow(entry) {
        const itemLabel = entry.itemName ? entry.itemName : `Item ${entry.itemId}`;
        const currLabel = entry.currencyName ? entry.currencyName : `${entry.currencyId}`;
        const bp = entry.itemIsBlueprint ? ' (BP)' : '';
        const cbp = entry.currencyIsBlueprint ? ' (BP)' : '';
        const stock = entry.amountInStock != null ? entry.amountInStock : '';
        return `<div class="order">
          <div class="sale">${entry.quantity} × ${itemLabel}${bp}</div>
          <div class="cost">${entry.costPerItem} × ${currLabel}${cbp}</div>
          <div class="stock">${stock}</div>
        </div>`;
      }

      async function fetchInfo() {
        try {
          const res = await fetch('/api/info');
          if (!res.ok) throw new Error('Failed to load server info');
          const info = await res.json();
          elServerName.textContent = `· ${info.name} · ${info.players}/${info.maxPlayers}`;
        } catch {}
      }

      let mapMeta = null;
      const state = { scale: 0.25, x: 0, y: 0, dragging: false, lastX: 0, lastY: 0, moved: false };
      let rerenderPending = false;
      let latestVending = null;
      let latestClusters = [];
      let searchIndex = [];
      let marketClaims = [];
      let activePopupMachineId = null;
      const claimsMap = new Map();

      function scheduleMarkerRerender() {
        if (rerenderPending) return;
        rerenderPending = true;
        requestAnimationFrame(() => {
          rerenderPending = false;
          if (latestVending) renderMarkers(latestVending);
        });
      }

      function applyTransform() {
        elMapImg.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
        elMarkerLayer.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
        scheduleMarkerRerender();
        updatePopupPosition();
      }

      function resetView() {
        state.scale = 0.25;
        state.x = 0;
        state.y = 0;
        applyTransform();
        hidePopup();
      }

      function zoomToImagePoint(px, py, factor = 1.5) {
        const newScale = Math.min(3, Math.max(0.1, state.scale * factor));
        const rect = elMapWrap.getBoundingClientRect();
        const cx = rect.width / 2;
        const cy = rect.height / 2;
        state.scale = newScale;
        state.x = cx - px * newScale;
        state.y = cy - py * newScale;
        applyTransform();
      }

      function mapToPixel(machine, meta) {
        const innerW = meta.width - 2 * meta.oceanMargin;
        const innerH = meta.height - 2 * meta.oceanMargin;
        const px = meta.oceanMargin + (machine.x / meta.mapSize) * innerW;
        const pyInner = (machine.y / meta.mapSize) * innerH;
        const py = meta.height - (meta.oceanMargin + pyInner);
        return { x: px, y: py };
      }
      
      function updatePopupPosition() {
        if (!mapMeta || !activePopupMachineId || !latestVending) return;
        const machine = latestVending.machines.find((m) => String(m.id) === String(activePopupMachineId));
        if (!machine) {
          hidePopup();
          return;
        }
        const pos = mapToPixel(machine, mapMeta);
        const scale = state.scale;
        const x = pos.x * scale + state.x;
        const y = pos.y * scale + state.y;
        const wrapRect = elMapWrap.getBoundingClientRect();
        const popupWidth = elPopup.offsetWidth || 280;
        const popupHeight = elPopup.offsetHeight || 200;
        const offsetX = Math.max(8, Math.min(wrapRect.width - popupWidth - 8, x + 10));
        const offsetY = Math.max(8, Math.min(wrapRect.height - popupHeight - 8, y - 10));
        elPopup.style.left = `${offsetX}px`;
        elPopup.style.top = `${offsetY}px`;
      }

      function clusterMachines(vending) {
        const thresholdScreen = 24;
        const tImg = thresholdScreen / state.scale;
        const clusters = [];
        for (const m of vending.machines) {
          const pos = mapToPixel(m, mapMeta);
          let best = null;
          let bd = 0;
          for (const c of clusters) {
            const dx = c.x - pos.x;
            const dy = c.y - pos.y;
            const d = Math.hypot(dx, dy);
            if (d <= tImg && (!best || d < bd)) {
              best = c;
              bd = d;
            }
          }
          if (best) {
            const n = best.items.length;
            best.x = (best.x * n + pos.x) / (n + 1);
            best.y = (best.y * n + pos.y) / (n + 1);
            best.items.push(m);
          } else {
            clusters.push({ x: pos.x, y: pos.y, items: [m] });
          }
        }
        return clusters;
      }

      function renderMarkers(vending) {
        if (!mapMeta) return;
        latestVending = vending;
        latestClusters = clusterMachines(vending);
        const markers = latestClusters
          .map((c, idx) => {
            if (c.items.length === 1) {
              const m = c.items[0];
              const title = m.name || `VM #${m.id}`;
              const isOwned = claimsMap.has(String(m.id));
              return `<div class="vm-marker${isOwned ? ' owned' : ''}" data-id="${m.id}" title="${title}" style="left:${c.x - 5}px;top:${c.y - 5}px;"></div>`;
            }
            return `<div class="cluster" data-cluster="${idx}" title="${c.items.length} vending machines" style="left:${c.x - 10}px;top:${c.y - 10}px;">${c.items.length}</div>`;
          })
          .join('');
        elMarkerLayer.innerHTML = markers;
      }

      function showPopupFor(id) {
        elSearchResults.style.display = 'none';
        if (!latestVending || !mapMeta) return;
        const machine = latestVending.machines.find((m) => String(m.id) === String(id));
        if (!machine) return;
        const claim = claimsMap.get(String(machine.id));
        const actionLabel = claim ? 'Release ownership' : 'Take ownership';
        const coordsText =
          machine.x != null && machine.y != null
            ? ` · Coords: (${machine.x.toFixed(0)}, ${machine.y.toFixed(0)})`
            : '';
        let html = `<div class="hdr">
          <div>
            <div class="title">${escapeHtml(machine.name || `Vending Machine #${machine.id}`)}</div>
            <div class="muted" style="font-size:12px">ID: ${escapeHtml(String(machine.id))}${coordsText}</div>
          </div>
          <span class="pill">${machine.outOfStock ? 'Out of stock' : 'Active'}</span>
        </div>`;
        const statusText = claim ? `Claimed by ${escapeHtml(claim.ownerId || 'Unknown')}` : 'Unclaimed';
        html += `<div class="hint">${statusText}</div>`;
        if (claim?.metadata) {
          html += `<div class="muted" style="font-size:11px;">Metadata: ${escapeHtml(
            typeof claim.metadata === 'string' ? claim.metadata : JSON.stringify(claim.metadata)
          )}</div>`;
        }
        const orders = Array.isArray(machine.sellOrders) ? machine.sellOrders : [];
        if (orders.length) {
          const rows = orders
            .map((order) => {
              const itemLabel = order.itemName
                ? escapeHtml(order.itemName)
                : escapeHtml(`Item ${order.itemId}`);
              const currencyLabel = escapeHtml(order.currencyName || String(order.currencyId ?? ''));
              const costValue =
                order.costPerItem != null ? escapeHtml(String(order.costPerItem)) : '—';
              const stockValue =
                order.amountInStock != null ? escapeHtml(String(order.amountInStock)) : '—';
              return `<tr><td><span class="popup-sale"><strong>${itemLabel}</strong></span></td><td><span class="popup-cost">${costValue} × ${currencyLabel}</span></td><td class="popup-stock">${stockValue}</td></tr>`;
            })
            .join('');
          html += `<table class="popup-table"><thead><tr><th>Item</th><th>Cost</th><th>Stock</th></tr></thead><tbody>${rows}</tbody></table>`;
        } else {
          html += `<div class="muted" style="font-size:12px">No items listed.</div>`;
        }
        html += `<div class="form-actions" style="justify-content:flex-end;margin-top:12px;"><button type="button" class="panel-link" data-claim-machine="${machine.id}">${actionLabel}</button></div>`;
        elPopup.innerHTML = html;
        activePopupMachineId = machine.id;
        elPopup.style.display = 'block';
        updatePopupPosition();
      }

      function hidePopup() {
        elPopup.style.display = 'none';
        activePopupMachineId = null;
      }

      elMapReset.addEventListener('click', resetView);
      elMapImg.addEventListener('dragstart', (e) => e.preventDefault());
      elMapWrap.addEventListener('contextmenu', (e) => e.preventDefault());
      elMapWrap.addEventListener('mousedown', (e) => {
        if (e.target && e.target.closest('#popup')) return;
        state.dragging = true;
        state.moved = false;
        state.lastX = e.clientX;
        state.lastY = e.clientY;
        elMapWrap.classList.add('dragging');
        elSearchResults.style.display = 'none';
      });
      window.addEventListener('mouseup', () => {
        state.dragging = false;
        elMapWrap.classList.remove('dragging');
      });
      window.addEventListener('mousemove', (e) => {
        if (!state.dragging) return;
        const dx = e.clientX - state.lastX;
        const dy = e.clientY - state.lastY;
        state.lastX = e.clientX;
        state.lastY = e.clientY;
        if (Math.abs(dx) > 2 || Math.abs(dy) > 2) state.moved = true;
        state.x += dx;
        state.y += dy;
        applyTransform();
      });
      elMapWrap.addEventListener(
        'wheel',
        (e) => {
          e.preventDefault();
          const factor = e.deltaY < 0 ? 1.1 : 0.9;
          const prev = state.scale;
          state.scale = Math.min(3, Math.max(0.1, state.scale * factor));
          const rect = elMapWrap.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;
          state.x = mx - (mx - state.x) * (state.scale / prev);
          state.y = my - (my - state.y) * (state.scale / prev);
          applyTransform();
        },
        { passive: false }
      );

      elMapWrap.addEventListener('click', (e) => {
        if (elPopup.contains(e.target)) return;
        elSearchResults.style.display = 'none';
        const target = e.target;
        if (target.classList.contains('vm-marker')) {
          if (state.moved) {
            state.moved = false;
            return;
          }
          const id = target.getAttribute('data-id');
          showPopupFor(id);
          e.stopPropagation();
          return;
        }
        if (target.classList.contains('cluster')) {
          if (state.moved) {
            state.moved = false;
            return;
          }
          const idx = Number(target.getAttribute('data-cluster'));
          const cluster = latestClusters[idx];
          if (!cluster) return;
          const preview = cluster.items
            .slice(0, 8)
            .map((m) => `<div><a href="#" class="vm-link" data-id="${m.id}">${m.name || `Vending Machine #${m.id}`}</a></div>`)
            .join('');
          elPopup.innerHTML = `<div class="hdr"><div class="title">${cluster.items.length} vending machines</div><button id="zoomInBtn" class="btn">Zoom in</button></div><div class="hint">Choose one:</div>${preview}`;
          const x = cluster.x * state.scale + state.x;
          const y = cluster.y * state.scale + state.y;
          const rect = elMapWrap.getBoundingClientRect();
          elPopup.style.left = `${Math.max(8, Math.min(rect.width - 440, x + 10))}px`;
          elPopup.style.top = `${Math.max(8, Math.min(rect.height - 320, y - 10))}px`;
          elPopup.style.display = 'block';
          const zoomBtn = document.getElementById('zoomInBtn');
          if (zoomBtn) {
            zoomBtn.onclick = (ev) => {
              ev.preventDefault();
              ev.stopPropagation();
              zoomToImagePoint(cluster.x, cluster.y, 1.6);
            };
          }
          return;
        }
        hidePopup();
      });

      elPopup.addEventListener('click', (e) => {
        const link = e.target.closest('.vm-link');
        if (!link) return;
        e.preventDefault();
        e.stopPropagation();
        const id = link.getAttribute('data-id');
        showPopupFor(id);
      });

      function buildSearchIndex(vending) {
        const entries = [];
        for (const m of vending.machines) {
          for (const o of m.sellOrders) {
            const itemLabel = o.itemName ? o.itemName : `Item ${o.itemId}`;
            entries.push({
              machineId: m.id,
              name: m.name || `Vending Machine #${m.id}`,
              x: m.x,
              y: m.y,
              itemId: o.itemId,
              item: itemLabel,
              currency: o.currencyName || `${o.currencyId}`,
              quantity: o.quantity,
              cost: o.costPerItem,
              stock: o.amountInStock != null ? o.amountInStock : '',
              key: `${(itemLabel || '').toLowerCase()} ${(o.currencyName || '').toLowerCase()} ${(m.name || '').toLowerCase()}`,
            });
          }
        }
        searchIndex = entries;
      }

      function renderSearchResults(query) {
        if (!query) {
          elSearchResults.style.display = 'none';
          elSearchResults.innerHTML = '';
          return;
        }
        const normalized = query.toLowerCase().trim();
        const results = searchIndex.filter((entry) => entry.key.includes(normalized)).slice(0, 40);
        if (!results.length) {
          elSearchResults.style.display = 'none';
          elSearchResults.innerHTML = '';
          return;
        }
        elSearchResults.style.display = 'block';
        elSearchResults.innerHTML = results
          .map(
            (entry) => `<a href="#" class="res" data-id="${entry.machineId}" style="display:block;padding:8px 10px;border-bottom:1px solid #1f2635;text-decoration:none;color:#dfe7f3">
              <div style="display:flex;justify-content:space-between;gap:12px"><div style="white-space:normal">${entry.quantity} × ${entry.item}</div><div style="color:#aab4c4;white-space:nowrap">${entry.cost} × ${entry.currency}${entry.stock !== '' ? ` · stock ${entry.stock}` : ''}</div></div>
              <div class="muted" style="font-size:11px;margin-top:2px">${entry.name} · (${entry.x.toFixed(0)}, ${entry.y.toFixed(0)})</div>
            </a>`
          )
          .join('');
      }

      elSearch.addEventListener('input', () => renderSearchResults(elSearch.value));
      elSearchResults.addEventListener('click', (e) => {
        const link = e.target.closest('a.res');
        if (!link) return;
        e.preventDefault();
        e.stopPropagation();
        const id = link.getAttribute('data-id');
        const machine = latestVending && latestVending.machines.find((m) => String(m.id) === String(id));
        if (machine) {
          const pos = mapToPixel(machine, mapMeta);
          zoomToImagePoint(pos.x, pos.y, 1.5);
          showPopupFor(id);
          elSearchResults.style.display = 'none';
        }
      });

      function getUniqueSearchSuggestions(query) {
        const normalized = (query || '').toLowerCase().trim();
        if (!searchIndex.length) return [];
        const seen = new Set();
        const results = [];
        for (const entry of searchIndex) {
          if (normalized && !entry.key.includes(normalized)) continue;
          const key = `${entry.item}|${entry.itemId ?? ''}`;
          if (seen.has(key)) continue;
          seen.add(key);
          results.push(entry);
          if (results.length >= 24) break;
        }
        return results;
      }


      function focusMachineOnMap(machineId) {
        if (!machineId || !latestVending || !mapMeta) return;
        const machine = latestVending.machines.find((m) => String(m.id) === String(machineId));
        if (!machine) return;
        const pos = mapToPixel(machine, mapMeta);
        zoomToImagePoint(pos.x, pos.y, 1.5);
        showPopupFor(machineId);
      }

      function renderClaims() {
        claimsMap.clear();
        
        if (!marketClaims.length) {
          elClaimsList.innerHTML = '<div class="muted">No owned machines.</div>';
          return;
        }
        
        elClaimsList.innerHTML = marketClaims
          .map((entry) => {
            const coords = entry.x != null && entry.y != null ? `(${entry.x.toFixed(0)}, ${entry.y.toFixed(0)})` : 'Coordinates unavailable';
            const claimedAt = entry.claim?.claimedAt ? new Date(entry.claim.claimedAt).toLocaleString() : 'Unknown';
            const metadataContent = entry.claim?.metadata;
            const metadata = metadataContent
              ? `<div class="muted" style="font-size:11px;">Metadata: ${escapeHtml(
                  typeof metadataContent === 'string' ? metadataContent : JSON.stringify(metadataContent)
                )}</div>`
              : '';
            claimsMap.set(String(entry.machineId), entry.claim);
            return `
            <div class="claim-row">
              <div class="claim-row-header">
                <strong>${escapeHtml(entry.machineName || `Vending Machine #${entry.machineId}`)}</strong>
                <span class="muted">ID: ${escapeHtml(entry.machineId)}</span>
              </div>
              <div class="claim-row-meta">
                <span>${coords}</span>
                <span>Owned: ${claimedAt}</span>
              </div>
              ${metadata}
              <div class="claim-row-actions">
                <button type="button" class="panel-link" data-focus-machine="${escapeHtml(entry.machineId)}">Focus on map</button>
                <button type="button" class="panel-link" data-claim-machine="${escapeHtml(entry.machineId)}">Release ownership</button>
              </div>
            </div>
          `;
          })
          .join('');
      }

      async function loadClaims(retryCount = 0) {
        elClaimsStatus.textContent = 'Loading owned machines…';
        const maxRetries = 3;
        
        try {
          const res = await fetch('/api/market/claims');
          if (!res.ok) {
            const errorText = await res.text();
            throw new Error(`Failed to load claims (${res.status}): ${errorText}`);
          }
          
          const data = await res.json();
          if (!data.success) {
            throw new Error(data.error || 'Server reported failure');
          }
          
          marketClaims = Array.isArray(data.claims) ? data.claims : [];
          renderClaims();
          elClaimsStatus.textContent = `Showing ${marketClaims.length} owned machine(s)`;
          if (activePopupMachineId) {
            showPopupFor(activePopupMachineId);
          }
          
          // Reset any error state
          elClaimsStatus.style.color = '';
          
        } catch (error) {
          console.error('Error loading claims:', error);
          
          if (retryCount < maxRetries) {
            // Exponential backoff retry
            const delay = Math.pow(2, retryCount) * 1000;
            elClaimsStatus.textContent = `Retrying... (${retryCount + 1}/${maxRetries})`;
            elClaimsStatus.style.color = '#f59e0b';
            
            await new Promise(resolve => setTimeout(resolve, delay));
            return loadClaims(retryCount + 1);
          } else {
            // Final failure
            elClaimsStatus.textContent = 'Unable to load owned machines';
            elClaimsStatus.style.color = '#ef4444';
            
            let errorMessage = error.message;
            if (errorMessage.includes('Failed to load claims')) {
              errorMessage = 'Server temporarily unavailable. Please try the refresh button.';
            }
            
            elClaimsList.innerHTML = `
              <div class="muted" style="color: #ef4444;">
                <strong>Error:</strong> ${escapeHtml(errorMessage)}<br>
                <small>Tip: Try clicking the "Refresh list" button in a moment.</small>
              </div>
            `;
          }
        }
      }

      elClaimsRefresh.addEventListener('click', () => {
        // Reset any error state and reload
        elClaimsStatus.style.color = '';
        elClaimsStatus.textContent = 'Refreshing...';
        loadClaims();
      });

      async function loadFreshVendingData(forceRefresh = false) {
        try {
          elRefresh.disabled = true;
          // Add cache-busting parameter when forceRefresh is true
          const url = forceRefresh ? '/api/vending-machines?force=true' : '/api/vending-machines';
          const res = await fetch(url);
          if (!res.ok) throw new Error('Request failed');
          const data = await res.json();
          latestVending = data;
          renderMarkers(data);
          buildSearchIndex(data);
          renderSearchResults(elSearch.value);
          renderMarketTracking(data); // This will trigger undercut recalculation
        } catch (error) {
          showError(error.message || String(error));
        } finally {
          elRefresh.disabled = false;
        }
      }

      async function updateOwnership(payload) {
        elClaimFeedback.textContent = 'Updating ownership…';
        elClaimFeedback.style.color = '';
        
        // Disable claim form during operation to prevent multiple rapid submissions
        const submitButton = elClaimForm.querySelector('button[type="submit"]');
        const originalButtonText = submitButton.textContent;
        submitButton.disabled = true;
        submitButton.textContent = 'Processing…';
        
        try {
          const res = await fetch('/api/market/claim', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          
          const data = await res.json();
          
          if (!res.ok || data.success === false) {
            throw new Error(data.error || `Server error (${res.status})`);
          }
          
          // Verify that the write operation completed on the server side
          if (!data.writeComplete) {
            console.warn('Server reported write may not be complete, proceeding with caution');
          }
          
          elClaimFeedback.textContent = data.message || 'Ownership updated';
          elClaimFeedback.style.color = '#22c55e';
          clearClaimForm();
          
          // Synchronized flow: Wait briefly, then reload claims with retry logic
          await new Promise(resolve => setTimeout(resolve, 200));
          
          // Load claims with retry mechanism
          await loadClaims();
          
          // Additional delay to ensure server has fully processed the change
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Force fresh data reload that bypasses cache
          await loadFreshVendingData(true);
          
          // Final timeout to ensure undercut detection uses fresh data
          setTimeout(() => {
            if (latestVending) {
              renderMarketTracking(latestVending);
            }
          }, 500);
          
        } catch (error) {
          console.error('Error in updateOwnership:', error);
          elClaimFeedback.textContent = `Error: ${error.message}`;
          elClaimFeedback.style.color = '#ef4444';
          
          // For network errors, suggest retry
          if (error.message.includes('fetch') || error.message.includes('network')) {
            setTimeout(() => {
              elClaimFeedback.innerHTML = `Error: ${escapeHtml(error.message)}<br><small>Check your connection and try again.</small>`;
            }, 1000);
          }
          
        } finally {
          // Re-enable the form
          submitButton.disabled = false;
          submitButton.textContent = originalButtonText;
          
          // Clear success message after 3 seconds
          if (elClaimFeedback.style.color === '#22c55e') {
            setTimeout(() => {
              elClaimFeedback.textContent = '';
              elClaimFeedback.style.color = '';
            }, 3000);
          }
        }
      }

      elClaimForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const machineIdValue = elClaimMachineId.value.trim();
        const machineNameValue = elClaimMachineName.value.trim();
        
        if (!machineIdValue) {
          elClaimFeedback.textContent = 'Machine ID is required';
          elClaimFeedback.style.color = '#f87171';
          return;
        }
        
        // Clear feedback
        elClaimFeedback.textContent = '';
        
        const payload = { machineId: machineIdValue };
        updateOwnership(payload);
      });
      
      // Machine name form - clear machine ID when user types in machine name
      elClaimMachineName.addEventListener('input', () => {
        const nameValue = elClaimMachineName.value.trim();
        if (nameValue === '') {
          // Clear the machine ID if user clears the name field
          if (elClaimMachineIdHint) {
            elClaimMachineIdHint.className = 'validation-hint';
            elClaimMachineIdHint.textContent = '';
          }
        }
      });
      
      // Machine ID form - clear validation when user types
      elClaimMachineId.addEventListener('input', () => {
        if (elClaimFeedback.textContent.includes('required')) {
          elClaimFeedback.textContent = '';
          elClaimFeedback.style.color = '';
        }
      });

      // Market Tracking functionality
      function normalizeCurrency(currencyName) {
        if (!currencyName) return '';
        const lower = currencyName.toLowerCase();
        if (lower.includes('scrap')) return 'scrap';
        if (lower.includes('high quality metal') || lower.includes('hqm')) return 'hqm';
        return lower;
      }

      function matchesCurrencyFilter(currencyName) {
        if (currencyFilter.type === 'all') return true;
        if (currencyFilter.type === 'other') {
          // When custom currency is selected, match exactly
          if (currencyFilter.custom && currencyFilter.custom.trim() !== '') {
            const normalizedInput = normalizeCurrency(currencyName);
            const normalizedCustom = normalizeCurrency(currencyFilter.custom);
            return normalizedInput === normalizedCustom;
          }
          // When no custom currency selected, exclude standard currencies (fallback behavior)
          const normalized = normalizeCurrency(currencyName);
          return normalized !== 'scrap' && normalized !== 'hqm';
        }
        return normalizeCurrency(currencyName) === currencyFilter.type;
      }

      function groupMarketData(vendingData) {
        const myOffers = new Map();
        const others = new Map();
        const ownedMachineIds = new Set(claimsMap.keys());

        // Group others by item name for nested display
        const othersByItem = new Map();

        // Process vending machine offers
        for (const machine of vendingData.machines) {
          const isOwned = ownedMachineIds.has(String(machine.id));
          
          for (const order of machine.sellOrders) {
            if (!matchesCurrencyFilter(order.currencyName)) continue;
             
            if (isOwned) {
              // Keep individual offers for My Offers
              const uniqueOfferKey = `${machine.id}|${order.itemId}|${order.currencyId}|${order.costPerItem}`;
              
              const offerData = {
                itemId: order.itemId,
                itemName: order.itemName || `Item ${order.itemId}`,
                currencyId: order.currencyId,
                currencyName: order.currencyName || `${order.currencyId}`,
                costPerItem: order.costPerItem,
                totalStock: order.amountInStock || 0,
                machineCount: 1,
                machineIds: [machine.id],
                machineId: machine.id,
                machineName: machine.name || `Vending Machine #${machine.id}`
              };
              
              myOffers.set(uniqueOfferKey, offerData);
            } else {
              // Group others by item name
              const itemName = order.itemName || `Item ${order.itemId}`;
              
              if (!othersByItem.has(itemName)) {
                othersByItem.set(itemName, {
                  itemName: itemName,
                  itemId: order.itemId,
                  offers: []
                });
              }
              
              othersByItem.get(itemName).offers.push({
                currencyId: order.currencyId,
                currencyName: order.currencyName || `${order.currencyId}`,
                costPerItem: order.costPerItem,
                totalStock: order.amountInStock || 0,
                machineId: machine.id,
                machineName: machine.name || `Vending Machine #${machine.id}`,
                x: machine.x,
                y: machine.y
              });
            }
          }
        }

        // Add manual offers to My Offers
        for (const manualOffer of manualOffers) {
          if (!matchesCurrencyFilter(manualOffer.currencyName)) continue;
          
          const uniqueOfferKey = `manual|${manualOffer.itemId || manualOffer.id}|${manualOffer.currencyName}|${manualOffer.costPerItem}`;
          
          const offerData = {
            itemId: manualOffer.itemId || manualOffer.id,
            itemName: manualOffer.itemName || manualOffer.item,
            currencyId: manualOffer.currencyName, // Manual offers use currency name as ID
            currencyName: manualOffer.currencyName,
            costPerItem: manualOffer.costPerItem || manualOffer.cost,
            totalStock: manualOffer.amountInStock || manualOffer.stock || 0,
            machineCount: 1,
            machineIds: ['manual'],
            machineId: 'manual',
            machineName: 'Manual Entry',
            isManual: true
          };
          
          myOffers.set(uniqueOfferKey, offerData);
        }

        return { myOffers, others: othersByItem };
      }

      function renderMarketTracking(vendingData) {
        const { myOffers, others } = groupMarketData(vendingData);
        const hasOwnedMachines = claimsMap.size > 0;

        // Always show manual entry for convenience, but highlight when no owned machines
        elManualEntry.style.display = 'block';
        const manualEntryMessage = elManualEntry.querySelector('.muted');
        if (manualEntryMessage) {
          if (!hasOwnedMachines) {
            manualEntryMessage.textContent =
              'No owned vending machines detected. Add manual offers to track your items.';
          } else {
            manualEntryMessage.textContent =
              'Add manual offers to supplement your owned machine data.';
          }
        }

        // Apply stock filtering to My Offers
        let filteredMyOffers = myOffers;
        if (!includeOutOfStockMyOffers) {
          filteredMyOffers = new Map(Array.from(myOffers.entries()).filter(([key, offer]) =>
            offer.totalStock > 0
          ));
        }

        // Render My Offers
        if (filteredMyOffers.size === 0) {
          elMyOffersBody.innerHTML = `<div class="muted">${hasOwnedMachines ? (includeOutOfStockMyOffers ? 'No items found in your owned machines.' : 'No in-stock items found in your owned machines.') : 'Your owned vending machines will populate this view.'}</div>`;
          elMyOffersSummary.textContent = hasOwnedMachines ? (includeOutOfStockMyOffers ? 'No offers' : 'No in-stock offers') : 'No offers yet';
        } else {
          const rows = Array.from(filteredMyOffers.values())
            .sort((a, b) => a.itemName.localeCompare(b.itemName))
            .map(offer => `
              <div class="tracking-row">
                <div class="tracking-row-details">
                  <div>${offer.itemName}</div>
                  <small>${offer.costPerItem} × ${offer.currencyName} · Stock: ${offer.totalStock} · ${offer.machineCount} machine${offer.machineCount !== 1 ? 's' : ''}</small>
                </div>
              </div>
            `).join('');
          elMyOffersBody.innerHTML = rows;
          elMyOffersSummary.textContent = includeOutOfStockMyOffers ? `${myOffers.size} offers` : `${filteredMyOffers.size}/${myOffers.size} in-stock`;
        }

        // Create Set of item names from "My Offers" for efficient matching
        const myOfferItemNames = new Set(Array.from(filteredMyOffers.values()).map(offer => offer.itemName));

        // Apply filtering to Others (now grouped by item name)
        let filteredOthers = new Map();
        let totalOffers = 0;
        let totalItems = 0;

        for (const [itemName, itemGroup] of others.entries()) {
          // Filter offers within each item group
          let filteredOffers = itemGroup.offers;
          
          if (!includeOutOfStockOthers) {
            filteredOffers = filteredOffers.filter(offer => offer.totalStock > 0);
          }
          
          // Apply "Match my offers" filter
          if (showOnlyMatchingItems && myOfferItemNames.size > 0) {
            if (!myOfferItemNames.has(itemName)) {
              continue; // Skip this item group entirely
            }
          }
          
          if (filteredOffers.length > 0) {
            // Sort offers within each item by currency type and amount
            filteredOffers.sort((a, b) => {
              // First sort by currency name
              const currencyCompare = a.currencyName.localeCompare(b.currencyName);
              if (currencyCompare !== 0) return currencyCompare;
              
              // Then sort by cost (lowest first)
              return a.costPerItem - b.costPerItem;
            });
            
            filteredOthers.set(itemName, {
              ...itemGroup,
              offers: filteredOffers
            });
            
            totalOffers += filteredOffers.length;
            totalItems++;
          }
        }

        // Render Others with grouped items
        if (filteredOthers.size === 0) {
          let message = 'Other players\' sell orders appear here.';
          const originalTotalOffers = Array.from(others.values()).reduce((sum, group) => sum + group.offers.length, 0);
          
          if (showOnlyMatchingItems && originalTotalOffers > 0) {
            message = `No matching items found (${originalTotalOffers} total offers)`;
          } else if (!includeOutOfStockOthers && originalTotalOffers > 0) {
            message = `No in-stock items found (${originalTotalOffers} total offers)`;
          }
          elOthersBody.innerHTML = `<div class="muted">${message}</div>`;
          
          elOthersSummary.textContent = showOnlyMatchingItems || !includeOutOfStockOthers
            ? `${totalOffers}/${originalTotalOffers} offers`
            : `${originalTotalOffers} offers`;
        } else {
          const originalTotalOffers = Array.from(others.values()).reduce((sum, group) => sum + group.offers.length, 0);
          
          // Create expandable item groups
          const itemGroups = Array.from(filteredOthers.entries())
            .sort((a, b) => a[0].localeCompare(b[0])) // Sort by item name
            .map(([itemName, itemGroup]) => {
              const offerRows = itemGroup.offers.map(offer => `
                <div class="offer-row">
                  <div class="offer-row-details">
                    <div>${offer.costPerItem} × ${offer.currencyName}</div>
                    <small>Stock: ${offer.totalStock} · ${offer.machineName}</small>
                  </div>
                  <div class="offer-row-actions">
                    ${offer.x != null && offer.y != null ?
                      `<button type="button" class="focus-offer-btn" data-focus-offer-machine="${offer.machineId}">Focus</button>` :
                      '<span class="muted" style="font-size: 11px;">No location</span>'
                    }
                  </div>
                </div>
              `).join('');
              
              return `
                <div class="item-group" data-item-name="${escapeHtml(itemName)}">
                  <div class="item-group-header">
                    <div class="item-name">${escapeHtml(itemName)}</div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                      <span class="offer-count">${itemGroup.offers.length} offer${itemGroup.offers.length !== 1 ? 's' : ''}</span>
                      <span class="item-group-chevron">▾</span>
                    </div>
                  </div>
                  <div class="item-group-offers">
                    ${offerRows}
                  </div>
                </div>
              `;
            }).join('');
          
          elOthersBody.innerHTML = itemGroups;
          
          elOthersSummary.textContent = showOnlyMatchingItems || !includeOutOfStockOthers
            ? `${totalOffers}/${originalTotalOffers} offers`
            : `${totalOffers} offers (${totalItems} items)`;
        }

        // Always check for undercuts to ensure banner and title are properly updated
        checkForUndercuts(filteredMyOffers, filteredOthers, vendingData);
      }

      function checkForUndercuts(myOffers, others, vendingData) {
        let hasUndercut = false;
        const undercutItems = [];

        // Ensure claimsMap is up-to-date before checking
        const ownedMachineIds = new Set(claimsMap.keys());

        // Flatten the grouped others data back to individual offers for undercut checking
        const allOtherOffers = [];
        for (const [itemName, itemGroup] of others.entries()) {
          for (const offer of itemGroup.offers) {
            allOtherOffers.push({
              ...offer,
              itemName: itemName,
              itemId: itemGroup.itemId
            });
          }
        }

        for (const [offerKey, myOffer] of myOffers) {
          const competingOffers = allOtherOffers
            .filter(other => {
              // Exclude offers from now-owned machines
              const isFromOwnedMachine = ownedMachineIds.has(String(other.machineId));
              const matchesItem = other.itemId === myOffer.itemId && other.currencyId === myOffer.currencyId;
              const isCheaper = other.costPerItem < myOffer.costPerItem;
              
              return !isFromOwnedMachine && matchesItem && isCheaper;
            })
            .sort((a, b) => a.costPerItem - b.costPerItem);

          if (competingOffers.length > 0) {
            hasUndercut = true;
            const bestCompetitor = competingOffers[0];
            
            undercutItems.push({
              itemName: myOffer.itemName,
              myCost: myOffer.costPerItem,
              bestCost: bestCompetitor.costPerItem,
              currencyName: myOffer.currencyName,
              bestMachineId: bestCompetitor.machineId,
              bestMachineName: bestCompetitor.machineName || 'Unknown'
            });
          }
        }

        // Enhanced rendering with banner
        if (hasUndercut) {
          // Show the eye-catching banner
          elUndercutBanner.style.display = 'block';
          
          // Change page title to indicate undercut warning
          document.title = '(!) UNDERCUT';
          
          const tableRows = undercutItems.map(item => {
            const focusButton = item.bestMachineId
              ? `<button type="button" class="focus-btn" data-focus-undercut-machine="${item.bestMachineId}">Focus on map</button>`
              : '<span class="muted" style="font-size: 11px;">Location unknown</span>';
            
            return `
              <tr>
                <td class="your-offer">${item.itemName}<br><small style="color: #22c55e;">${item.myCost} × ${item.currencyName}</small></td>
                <td class="best-offer">${item.bestCost} × ${item.currencyName}</td>
                <td>${focusButton}</td>
              </tr>
            `;
          }).join('');
          
          elTrackingWarning.style.display = 'none'; // Hide the old warning
          elTrackingWarningTable.innerHTML = `
            <table class="undercut-table">
              <thead>
                <tr>
                  <th>Your Offer</th>
                  <th>Best Offer</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody>
                ${tableRows}
              </tbody>
            </table>
          `;
          elTrackingWarningTable.style.display = 'block';
          
          // Play chime sound
          chimeAudio.play().catch(() => {
            // Ignore audio playback errors
          });
        } else {
          // Hide both banner and table when no undercuts
          elUndercutBanner.style.display = 'none';
          elTrackingWarning.style.display = 'none';
          elTrackingWarningTable.style.display = 'none';
          
          // Revert page title to default
          document.title = 'RustMarket Tracker';
        }
      }

      // Manual entry functionality
      function loadManualOffers() {
        const stored = localStorage.getItem('manualMarketOffers');
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            manualOffers.length = 0;
            manualOffers.push(...parsed);
          } catch (e) {
            console.error('Failed to load manual offers:', e);
          }
        }
      }

      function saveManualOffers() {
        try {
          localStorage.setItem('manualMarketOffers', JSON.stringify(manualOffers));
        } catch (e) {
          console.error('Failed to save manual offers:', e);
        }
      }

      // Enhanced Validation Functions
      function validateManualOfferForm() {
        let isValid = true;
        
        // Validate item
        const itemValue = elManualItem.value.trim();
        if (!itemValue) {
          showFieldError(elManualItemError, 'Item is required');
          isValid = false;
        } else {
          const selectedItem = itemAutocomplete?.getSelectedItem();
          if (!selectedItem || selectedItem.name !== itemValue) {
            showFieldError(elManualItemError, 'Please select a valid item from the search results');
            isValid = false;
          } else {
            hideFieldError(elManualItemError);
          }
        }
        
        // Validate currency
        const currencyValue = elManualCurrency.value.trim();
        if (!currencyValue) {
          showFieldError(elManualCurrencyError, 'Currency is required');
          isValid = false;
        } else {
          const selectedCurrency = currencyAutocomplete?.getSelectedItem();
          if (!selectedCurrency || selectedCurrency.name !== currencyValue) {
            showFieldError(elManualCurrencyError, 'Please select a valid currency');
            isValid = false;
          } else {
            hideFieldError(elManualCurrencyError);
          }
        }
        
        // Validate cost
        const costValue = parseFloat(elManualCost.value);
        if (isNaN(costValue) || costValue < 0) {
          showFieldError(elManualCostError, 'Cost must be a positive number');
          isValid = false;
        } else if (costValue > 1000000) {
          showFieldError(elManualCostError, 'Cost seems unusually high');
          isValid = false;
        } else {
          hideFieldError(elManualCostError);
        }
        
        // Validate stock (optional)
        const stockValue = parseInt(elManualStock.value) || 0;
        if (stockValue < 0) {
          showFieldError(elManualStockError, 'Stock cannot be negative');
          isValid = false;
        } else if (stockValue > 100000) {
          showFieldError(elManualStockError, 'Stock seems unusually high');
          isValid = false;
        } else {
          hideFieldError(elManualStockError);
        }
        
        return isValid;
      }
      
      function showFieldError(errorElement, message) {
        if (errorElement) {
          errorElement.textContent = message;
          errorElement.classList.add('active');
        }
      }
      
      function hideFieldError(errorElement) {
        if (errorElement) {
          errorElement.classList.remove('active');
          errorElement.textContent = '';
        }
      }
      
      function clearAllFieldErrors() {
        [elManualItemError, elManualCurrencyError, elManualCostError, elManualStockError, elClaimMachineNameError, elTrackingCurrencyOtherError].forEach(el => {
          if (el) hideFieldError(el);
        });
        
        [elManualItemHint, elManualCurrencyHint, elManualCostHint, elManualStockHint, elClaimMachineNameHint, elClaimMachineIdHint].forEach(el => {
          if (el) {
            el.classList.remove('success', 'error');
            el.textContent = '';
          }
        });
        
        // Also reset the checkmark
        const checkmark = document.getElementById('trackingCurrencyOtherCheckmark');
        if (checkmark) {
          checkmark.style.opacity = '0';
        }
      }
      
      function addManualOffer() {
        clearAllFieldErrors();
        
        if (!validateManualOfferForm()) {
          return;
        }
        
        const itemValue = elManualItem.value.trim();
        const currencyValue = elManualCurrency.value.trim();
        const costValue = parseFloat(elManualCost.value);
        const stockValue = parseInt(elManualStock.value) || 0;
        
        // Get detailed item information from search index
        const itemData = searchIndex.find(entry =>
          (entry.item || entry.itemName) === itemValue
        );
        
        const offer = {
          id: Date.now().toString(),
          itemId: itemData?.itemId || null,
          itemName: itemValue,
          currencyName: currencyValue,
          costPerItem: costValue,
          amountInStock: stockValue,
          totalStock: stockValue,
          machineCount: 1,
          machineIds: ['manual'],
          machineId: 'manual',
          machineName: 'Manual Entry',
          addedAt: new Date().toISOString(),
          isManual: true
        };
        
        manualOffers.push(offer);
        saveManualOffers();
        
        // Clear form
        clearManualForm();
        
        // Refresh display
        renderManualOffers();
        
        // Show success message
        elClaimFeedback.textContent = `✓ Added manual offer: ${itemValue}`;
        elClaimFeedback.style.color = '#22c55e';
        
        // Clear success message after 3 seconds
        setTimeout(() => {
          elClaimFeedback.textContent = '';
          elClaimFeedback.style.color = '';
        }, 3000);
      }
      
      function clearManualForm() {
        elManualItem.value = '';
        elManualCurrency.value = '';
        elManualCost.value = '';
        elManualStock.value = '';
        
        // Reset autocomplete states
        if (itemAutocomplete) {
          itemAutocomplete.reset();
        }
        if (currencyAutocomplete) {
          currencyAutocomplete.reset();
        }
        
        clearAllFieldErrors();
      }
      
      // Clear claim form function
      function clearClaimForm() {
        elClaimMachineName.value = '';
        elClaimMachineId.value = '';
        
        // Reset autocomplete states
        if (machineNameAutocomplete) {
          machineNameAutocomplete.reset();
        }
        
        // Clear validation hints
        if (elClaimMachineNameHint) {
          elClaimMachineNameHint.className = 'validation-hint';
          elClaimMachineNameHint.textContent = '';
        }
        if (elClaimMachineIdHint) {
          elClaimMachineIdHint.className = 'validation-hint';
          elClaimMachineIdHint.textContent = '';
        }
        
        clearAllFieldErrors();
      }
      
      // Quick add functionality
      function handleQuickAdd(itemName, currencyName) {
        elManualItem.value = itemName;
        elManualCurrency.value = currencyName;
        
        // Trigger validation highlights
        setTimeout(() => {
          const mockItem = { name: itemName };
          const mockCurrency = { name: currencyName };
          
          if (validateItemSelection(mockItem)) {
            itemAutocomplete.selectedItem = mockItem;
          }
          
          if (validateCurrencySelection(mockCurrency)) {
            currencyAutocomplete.selectedItem = mockCurrency;
          }
        }, 100);
        
        // Focus on cost field
        elManualCost.focus();
      }

      function renderManualOffers() {
        if (manualOffers.length === 0) {
          elMyOffersBody.innerHTML = '<div class="muted">Add manual offers to track your items.</div>';
          elMyOffersSummary.textContent = 'No offers';
          return;
        }

        const rows = manualOffers
          .sort((a, b) => (a.itemName || a.item).localeCompare(b.itemName || b.item))
          .map(offer => `
            <div class="tracking-row" style="border-left: 3px solid #22c55e;">
              <div class="tracking-row-details">
                <div>${offer.itemName || offer.item}</div>
                <small>${offer.costPerItem || offer.cost} × ${offer.currencyName || offer.currency} · Stock: ${offer.amountInStock || offer.stock} · Manual entry</small>
              </div>
              <div class="tracking-row-actions">
                <button type="button" onclick="removeManualOffer('${offer.id}')" style="background:#ef444;color:white;border:none;padding:4px 8px;border-radius:4px;font-size:11px;">Remove</button>
              </div>
            </div>
          `).join('');
        
        elMyOffersBody.innerHTML = rows;
        elMyOffersSummary.textContent = `${manualOffers.length} manual offer${manualOffers.length !== 1 ? 's' : ''}`;

        // Add clear all button if there are offers
        if (manualOffers.length > 0) {
          const clearButton = document.createElement('div');
          clearButton.innerHTML = `
            <div style="margin-top:8px;text-align:center;">
              <button type="button" onclick="clearAllManualOffers()" class="ghost" style="font-size:11px;">Clear all manual offers</button>
            </div>
          `;
          elMyOffersBody.appendChild(clearButton.firstElementChild);
        }
      }

      function removeManualOffer(id) {
        const index = manualOffers.findIndex(offer => offer.id === id);
        if (index !== -1) {
          manualOffers.splice(index, 1);
          saveManualOffers();
          renderManualOffers();
        }
      }

      function clearAllManualOffers() {
        if (confirm('Are you sure you want to clear all manual offers?')) {
          manualOffers.length = 0;
          saveManualOffers();
          renderManualOffers();
        }
      }

      // Currency filter handling with smart lookup
      elTrackingCurrency.addEventListener('change', () => {
        const value = elTrackingCurrency.value;
        if (value === 'other') {
          elTrackingCurrencyOtherContainer.style.display = 'block';
          elTrackingCurrencyOther.focus();
          currencyFilter = { type: 'other', custom: elTrackingCurrencyOther.value.trim() };
          
          // Reset autocomplete when opened
          if (trackingCurrencyAutocomplete) {
            trackingCurrencyAutocomplete.reset();
          }
        } else {
          elTrackingCurrencyOtherContainer.style.display = 'none';
          currencyFilter = { type: value, custom: '' };
          
          // Reset validation hints
          const checkmark = document.getElementById('trackingCurrencyOtherCheckmark');
          if (checkmark) {
            checkmark.style.opacity = '0';
          }
          if (trackingCurrencyAutocomplete) {
            trackingCurrencyAutocomplete.reset();
          }
        }
        
        if (latestVending) {
          renderMarketTracking(latestVending);
        }
      });

      // Enhanced currency other input handling with autocomplete integration
      elTrackingCurrencyOther.addEventListener('input', () => {
        const customValue = elTrackingCurrencyOther.value.trim();
        currencyFilter.custom = customValue;
        
        // Clear validation on input change
        if (customValue === '') {
          const checkmark = document.getElementById('trackingCurrencyOtherCheckmark');
          if (checkmark) {
            checkmark.style.opacity = '0';
          }
        }
        
        if (latestVending) {
          renderMarketTracking(latestVending);
        }
      });

      // Enhanced Manual offer event listeners
      if (elManualAdd) {
        elManualAdd.addEventListener('click', addManualOffer);
      }
      
      if (elManualClear) {
        elManualClear.addEventListener('click', clearManualForm);
      }
      
      // Quick add event listeners
      if (elQuickAddChips) {
        elQuickAddChips.addEventListener('click', (e) => {
          const chip = e.target.closest('.quick-add-chip');
          if (chip) {
            const itemName = chip.dataset.item;
            const currencyName = chip.dataset.currency;
            handleQuickAdd(itemName, currencyName);
          }
        });
      }
      
      // Input validation listeners
      if (elManualCost) {
        elManualCost.addEventListener('input', () => {
          const cost = parseFloat(elManualCost.value);
          if (!isNaN(cost) && cost >= 0) {
            hideFieldError(elManualCostError);
            if (cost > 0) {
              elManualCostHint.textContent = '';
              elManualCostHint.classList.remove('error');
            }
          }
        });
      }
      
      if (elManualStock) {
        elManualStock.addEventListener('input', () => {
          const stock = parseInt(elManualStock.value);
          if (!isNaN(stock) && stock >= 0) {
            hideFieldError(elManualStockError);
          }
        });
      }

      // Make functions globally accessible
      window.removeManualOffer = removeManualOffer;
      window.clearAllManualOffers = clearAllManualOffers;
      
      // Initialize autocompletes when page loads
      document.addEventListener('DOMContentLoaded', () => {
        if (searchIndex.length > 0) {
          initializeAutocompletes();
        }
      });

      // Refresh tracking button
      elTrackingRefresh.addEventListener('click', async () => {
        await loadFreshVendingData();
      });

      // Event listeners for stock filter toggles
      elMyOffersStockToggle.addEventListener('change', () => {
        includeOutOfStockMyOffers = elMyOffersStockToggle.checked;
        saveFilterState();
        if (latestVending) {
          renderMarketTracking(latestVending);
        }
      });

      elOthersStockToggle.addEventListener('change', () => {
        includeOutOfStockOthers = elOthersStockToggle.checked;
        saveFilterState();
        if (latestVending) {
          renderMarketTracking(latestVending);
        }
      });

      // Event listener for matching filter toggle
      elOthersFilterToggle.addEventListener('change', () => {
        showOnlyMatchingItems = elOthersFilterToggle.checked;
        saveFilterState();
        if (latestVending) {
          renderMarketTracking(latestVending);
        }
      });

      document.querySelectorAll('.panel .panel-header').forEach((header) => {
        header.addEventListener('click', () => {
          const panel = header.closest('.panel');
          if (!panel) return;
          const open = panel.getAttribute('data-open') === 'true';
          panel.setAttribute('data-open', open ? 'false' : 'true');
        });
      });

      document.addEventListener('click', (event) => {
        const focusButton = event.target.closest('[data-focus-machine]');
        if (focusButton) {
          event.preventDefault();
          focusMachineOnMap(focusButton.dataset.focusMachine);
          return;
        }
        
        const focusUndercutButton = event.target.closest('[data-focus-undercut-machine]');
        if (focusUndercutButton) {
          event.preventDefault();
          focusMachineOnMap(focusUndercutButton.dataset.focusUndercutMachine);
          return;
        }
        
        const focusOfferButton = event.target.closest('[data-focus-offer-machine]');
        if (focusOfferButton) {
          event.preventDefault();
          focusMachineOnMap(focusOfferButton.dataset.focusOfferMachine);
          return;
        }
        
        const claimButton = event.target.closest('[data-claim-machine]');
        if (claimButton) {
          event.preventDefault();
          const machineId = claimButton.dataset.claimMachine;
          if (!machineId) return;
          const claim = claimsMap.get(String(machineId));
          elClaimMachineId.value = machineId;
          elClaimFeedback.textContent = '';
          const payload = claim ? { machineId, release: true } : { machineId };
          updateOwnership(payload);
          return;
        }
        
        // Handle item group expand/collapse
        const itemGroupHeader = event.target.closest('.item-group-header');
        if (itemGroupHeader) {
          event.preventDefault();
          const itemGroup = itemGroupHeader.closest('.item-group');
          if (itemGroup) {
            const isExpanded = itemGroup.classList.contains('expanded');
            if (isExpanded) {
              itemGroup.classList.remove('expanded');
            } else {
              itemGroup.classList.add('expanded');
            }
          }
          return;
        }
      });

      function fitMapToViewport() {
        if (!mapMeta) return;
        const rect = elMapWrap.getBoundingClientRect();
        const scale = Math.min(rect.width / mapMeta.width, rect.height / mapMeta.height);
        state.scale = scale;
        state.x = (rect.width - mapMeta.width * scale) / 2;
        state.y = (rect.height - mapMeta.height * scale) / 2;
        applyTransform();
      }

      async function loadMap() {
        try {
          const res = await fetch('/api/map');
          if (!res.ok) throw new Error('Failed to load map');
          mapMeta = await res.json();
          elMapImg.src = '/api/map.jpg';
          elMapImg.onload = () => {
            fitMapToViewport();
            const factor = Math.min(Math.pow(1.1, 10), 3 / state.scale);
            const cx = mapMeta.width / 2;
            const cy = mapMeta.height / 2;
            zoomToImagePoint(cx, cy, factor);
          };
        } catch {}
      }

      async function load() {
        elRefresh.disabled = true;
        elStatus.textContent = 'Loading…';
        clearError();
        try {
          await fetchInfo();
          const res = await fetch('/api/vending-machines');
          if (!res.ok) throw new Error('Request failed');
          const data = await res.json();
          elStatus.textContent = `${data.count} vending machines`;
          renderMarkers(data);
          buildSearchIndex(data);
          renderSearchResults(elSearch.value);
          await loadClaims();
          renderMarketTracking(data);
        } catch (error) {
          showError(error.message || String(error));
          elStatus.textContent = 'Failed to load';
        } finally {
          elRefresh.disabled = false;
        }
      }

      elRefresh.addEventListener('click', load);
      
      // Initialize manual offers on page load
      loadManualOffers();
      renderManualOffers();
      loadFilterState();
      
      Promise.all([loadMap().then(() => {
        load().then(() => {
          // Initialize autocompletes after data is loaded
            if (searchIndex.length > 0 && !itemAutocomplete) {
              initializeAutocompletes();
            }
            
            // Also initialize machine name autocomplete if vending data is available
            if (latestVending && latestVending.machines && !machineNameAutocomplete) {
              // Re-initialize to include machine name and tracking currency autocompletes
              initializeAutocompletes();
            }
        });
      })]);
      setInterval(load, 30000);

      // Auto-refresh market tracking every 30 seconds
      setInterval(() => {
        if (latestVending) {
          renderMarketTracking(latestVending);
        }
      }, 30000);
      
      // COMPREHENSIVE TESTING FUNCTION
      window.runComprehensiveTests = async function() {
        console.log('🧪 STARTING COMPREHENSIVE TESTS FOR RUST MARKETS FIXES');
        const testResults = {
          fix1: { name: 'Owned Machines Panel Height', status: 'pending', issues: [], successes: [] },
          fix2: { name: 'Manual Offer Form Redesign', status: 'pending', issues: [], successes: [] },
          fix3: { name: 'Smart Currency Lookup UI Alignment', status: 'pending', issues: [], successes: [] },
          fix4: { name: 'Smart Currency Lookup Functionality', status: 'pending', issues: [], successes: [] },
          integration: { name: 'Market Tracking Integration', status: 'pending', issues: [], successes: [] }
        };
        
        // TEST FIX 1: Owned Machines Panel Height
        console.log('📏 Testing Fix 1: Owned Machines Panel Height');
        try {
          const sidebar = document.querySelector('.sidebar');
          const panel = document.querySelector('.panel');
          const panelList = document.querySelector('.panel-list');
          
          // Test 1.1: Check if sidebar has proper height styles
          if (sidebar) {
            const computedStyle = window.getComputedStyle(sidebar);
            const hasHeight = computedStyle.height && computedStyle.height.includes('vh');
            const hasMaxHeight = computedStyle.maxHeight && computedStyle.maxHeight.includes('vh');
            
            if (hasHeight && hasMaxHeight) {
              testResults.fix1.successes.push('✅ Sidebar has proper viewport-relative height');
              console.log('✅ Sidebar height test passed');
            } else {
              testResults.fix1.issues.push('❌ Sidebar missing proper viewport height styles');
              console.log('❌ Sidebar height test failed');
            }
            
            // Test 1.2: Check sticky positioning
            if (computedStyle.position === 'sticky') {
              testResults.fix1.successes.push('✅ Sidebar has sticky positioning');
              console.log('✅ Sticky positioning test passed');
            } else {
              testResults.fix1.issues.push('❌ Sidebar missing sticky positioning');
              console.log('❌ Sticky positioning test failed');
            }
          } else {
            testResults.fix1.issues.push('❌ Sidebar element not found');
          }
          
          testResults.fix1.status = testResults.fix1.issues.length === 0 ? 'passed' : 'failed';
          
        } catch (error) {
          testResults.fix1.status = 'error';
          testResults.fix1.issues.push(`❌ Error testing Fix 1: ${error.message}`);
        }
        
        // TEST FIX 2: Manual Offer Form Redesign
        console.log('🔍 Testing Fix 2: Manual Offer Form Redesign');
        try {
          // Test 2.1: Check if autocomplete classes exist
          if (typeof SmartAutocomplete !== 'undefined') {
            testResults.fix2.successes.push('✅ SmartAutocomplete class is defined');
            console.log('✅ SmartAutocomplete class test passed');
          } else {
            testResults.fix2.issues.push('❌ SmartAutocomplete class not found');
          }
          
          // Test 2.2: Check if autocomplete instances are initialized
          if (itemAutocomplete && currencyAutocomplete) {
            testResults.fix2.successes.push('✅ Autocomplete instances are initialized');
            console.log('✅ Autocomplete instances test passed');
          } else {
            testResults.fix2.issues.push('❌ Autocomplete instances not initialized');
            console.log('❌ Autocomplete instances test failed', { itemAutocomplete, currencyAutocomplete });
          }
          
          // Test 2.3: Test fuzzy search function
          if (typeof fuzzySearch === 'function') {
            const testItems = [
              { name: 'Scrap', details: 'Common material' },
              { name: 'High Quality Metal', details: 'Rare material' }
            ];
            const searchResults = fuzzySearch('scr', testItems, ['name', 'details']);
            if (searchResults.length > 0) {
              testResults.fix2.successes.push('✅ Fuzzy search function working');
              console.log('✅ Fuzzy search test passed', searchResults);
            } else {
              testResults.fix2.issues.push('❌ Fuzzy search not returning results');
            }
          } else {
            testResults.fix2.issues.push('❌ Fuzzy search function not defined');
          }
          
          testResults.fix2.status = testResults.fix2.issues.length === 0 ? 'passed' : 'failed';
          
        } catch (error) {
          testResults.fix2.status = 'error';
          testResults.fix2.issues.push(`❌ Error testing Fix 2: ${error.message}`);
        }
        
        // TEST FIX 3: Smart Currency Lookup UI Alignment
        console.log('🎨 Testing Fix 3: Smart Currency Lookup UI Alignment');
        try {
          const trackingFilter = document.querySelector('.tracking-filter');
          const trackingFilterRow = document.querySelector('.tracking-filter-row');
          const currencySelect = document.getElementById('trackingCurrency');
          const currencyOtherContainer = document.getElementById('trackingCurrencyOtherContainer');
          
          // Test 3.1: Check if tracking filter has proper flex layout
          if (trackingFilter && window.getComputedStyle(trackingFilter).display === 'flex') {
            testResults.fix3.successes.push('✅ Tracking filter has flex layout');
            console.log('✅ Tracking filter flex layout test passed');
          } else {
            testResults.fix3.issues.push('❌ Tracking filter missing proper flex layout');
            console.log('❌ Tracking filter flex layout test failed');
          }
          
          // Test 3.2: Check if tracking filter row exists and has proper alignment
          if (trackingFilterRow) {
            const rowStyle = window.getComputedStyle(trackingFilterRow);
            if (rowStyle.display === 'flex' && rowStyle.alignItems === 'center') {
              testResults.fix3.successes.push('✅ Filter row has proper flex alignment');
              console.log('✅ Filter row alignment test passed');
            } else {
              testResults.fix3.issues.push('❌ Filter row missing proper flex alignment');
              console.log('❌ Filter row alignment test failed');
            }
          } else {
            testResults.fix3.issues.push('❌ Tracking filter row not found');
          }
          
          // Test 3.3: Check if autocomplete container has proper sizing
          if (currencyOtherContainer) {
            const containerStyle = window.getComputedStyle(currencyOtherContainer);
            if (containerStyle.flex === '1 1 0%' || containerStyle.flex === '1') {
              testResults.fix3.successes.push('✅ Autocomplete container has flex sizing');
              console.log('✅ Autocomplete container sizing test passed');
            } else {
              testResults.fix3.issues.push('❌ Autocomplete container missing proper flex sizing');
              console.log('❌ Autocomplete container sizing test failed');
            }
          } else {
            testResults.fix3.issues.push('❌ Currency other container not found');
          }
          
          testResults.fix3.status = testResults.fix3.issues.length === 0 ? 'passed' : 'failed';
          
        } catch (error) {
          testResults.fix3.status = 'error';
          testResults.fix3.issues.push(`❌ Error testing Fix 3: ${error.message}`);
        }
        
        // TEST FIX 4: Smart Currency Lookup Functionality
        console.log('💰 Testing Fix 4: Smart Currency Lookup Functionality');
        try {
          // Test 4.1: Check if tracking currency autocomplete is initialized
          if (trackingCurrencyAutocomplete) {
            testResults.fix4.successes.push('✅ Tracking currency autocomplete is initialized');
            console.log('✅ Tracking currency autocomplete initialization test passed');
          } else {
            testResults.fix4.issues.push('❌ Tracking currency autocomplete not initialized');
            console.log('❌ Tracking currency autocomplete initialization test failed');
          }
          
          // Test 4.2: Test currency filter functionality
          const originalFilter = { ...currencyFilter };
          
          // Test "Other" selection
          elTrackingCurrency.value = 'other';
          elTrackingCurrency.dispatchEvent(new Event('change'));
          
          setTimeout(() => {
            if (elTrackingCurrencyOtherContainer.style.display !== 'none') {
              testResults.fix4.successes.push('✅ Currency other container appears on selection');
              console.log('✅ Currency other container appearance test passed');
            } else {
              testResults.fix4.issues.push('❌ Currency other container does not appear on selection');
              console.log('❌ Currency other container appearance test failed');
            }
            
            // Test "All" selection
            elTrackingCurrency.value = 'all';
            elTrackingCurrency.dispatchEvent(new Event('change'));
            
            setTimeout(() => {
              if (elTrackingCurrencyOtherContainer.style.display === 'none') {
                testResults.fix4.successes.push('✅ Currency other container hides on other selection');
                console.log('✅ Currency other container hiding test passed');
              } else {
                testResults.fix4.issues.push('❌ Currency other container does not hide on other selection');
                console.log('❌ Currency other container hiding test failed');
              }
              
              // Test 4.3: Test matchesCurrencyFilter function
              const testCases = [
                { type: 'all', custom: '', input: 'Scrap', expected: true },
                { type: 'scrap', custom: '', input: 'Scrap', expected: true },
                { type: 'scrap', custom: '', input: 'HQM', expected: false },
                { type: 'other', custom: 'Metal Fragments', input: 'Metal Fragments', expected: true },
                { type: 'other', custom: 'Metal Fragments', input: 'Wood', expected: false }
              ];
              
              let filterTestsPassed = 0;
              testCases.forEach(testCase => {
                currencyFilter = { type: testCase.type, custom: testCase.custom };
                const result = matchesCurrencyFilter(testCase.input);
                if (result === testCase.expected) {
                  filterTestsPassed++;
                } else {
                  testResults.fix4.issues.push(`❌ Filter test failed: ${testCase.type}/${testCase.custom} -> ${testCase.input} expected ${testCase.expected}, got ${result}`);
                }
              });
              
              if (filterTestsPassed === testCases.length) {
                testResults.fix4.successes.push('✅ All currency filter tests passed');
                console.log('✅ Currency filter logic tests passed');
              }
              
              // Restore original filter
              currencyFilter = originalFilter;
              testResults.fix4.status = testResults.fix4.issues.length === 0 ? 'passed' : 'failed';
              
            }, 100);
          }, 100);
          
        } catch (error) {
          testResults.fix4.status = 'error';
          testResults.fix4.issues.push(`❌ Error testing Fix 4: ${error.message}`);
        }
        
        // Generate comprehensive report
        console.log('📊 COMPREHENSIVE TEST RESULTS:');
        console.group('Test Results Summary');
        
        Object.entries(testResults).forEach(([key, results]) => {
          console.log(`${results.name}: ${results.status.toUpperCase()}`);
          if (results.successes.length > 0) {
            results.successes.forEach(success => console.log(`  ${success}`));
          }
          if (results.issues.length > 0) {
            results.issues.forEach(issue => console.log(`  ${issue}`));
          }
        });
        
        console.groupEnd();
        
        // Return results for programmatic access
        return testResults;
      };
      
      // Auto-run tests when page loads (after a delay to ensure everything is initialized)
      setTimeout(() => {
        console.log('🚀 Auto-running comprehensive tests...');
        window.runComprehensiveTests();
      }, 3000);
    </script>
  </body>
</html>
